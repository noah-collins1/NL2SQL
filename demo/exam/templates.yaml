# BIRD-style ERP question templates
# Fields: id, difficulty, question, evidence, tables, columns, tags, gold_sql

- id: sales_top_customers
  difficulty: moderate
  question: "Top 10 customers by total sales amount in {year}?"
  evidence: "Use order date; 'total sales' = sum(order_lines.quantity * order_lines.unit_price)."
  tables: [sales_orders, order_lines, customers]
  columns: [sales_orders.order_date, order_lines.quantity, order_lines.unit_price, customers.name]
  tags: [sales, top_n, aggregation]
  gold_sql: |
    SELECT c.name, SUM(ol.quantity * ol.unit_price) AS total_sales
    FROM {schema}.sales_orders so
    JOIN {schema}.order_lines ol ON ol.order_id = so.order_id
    JOIN {schema}.customers c ON c.customer_id = so.customer_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY c.name
    ORDER BY total_sales DESC
    LIMIT 10;

- id: ar_open_invoices
  difficulty: simple
  question: "List open AR invoices over {amount} in {year}."
  evidence: "AR invoices are in finance_ar_invoices."
  tables: [finance_ar_invoices]
  columns: [finance_ar_invoices.amount, finance_ar_invoices.status, finance_ar_invoices.invoice_date]
  tags: [finance, ar]
  gold_sql: |
    SELECT ar_invoice_id, invoice_number, amount, status
    FROM {schema}.finance_ar_invoices
    WHERE status = 'open'
      AND amount > {amount}
      AND EXTRACT(YEAR FROM invoice_date) = {year};

- id: ar_late_rate
  difficulty: moderate
  question: "What percentage of AR invoices were late in {year}?"
  evidence: "Late invoices have status = 'late'."
  tables: [finance_ar_invoices]
  columns: [finance_ar_invoices.status, finance_ar_invoices.invoice_date]
  tags: [finance, ar, rate]
  gold_sql: |
    SELECT
      ROUND(100.0 * SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) / COUNT(*), 2) AS late_pct
    FROM {schema}.finance_ar_invoices
    WHERE EXTRACT(YEAR FROM invoice_date) = {year};

- id: ap_by_vendor
  difficulty: moderate
  question: "Total AP invoice amount by vendor for {year}."
  evidence: "Join finance_ap_invoices to vendors."
  tables: [finance_ap_invoices, vendors]
  columns: [finance_ap_invoices.amount, finance_ap_invoices.invoice_date, vendors.name]
  tags: [finance, ap]
  gold_sql: |
    SELECT v.name, SUM(ai.amount) AS total_amount
    FROM {schema}.finance_ap_invoices ai
    JOIN {schema}.vendors v ON v.vendor_id = ai.vendor_id
    WHERE EXTRACT(YEAR FROM ai.invoice_date) = {year}
    GROUP BY v.name
    ORDER BY total_amount DESC;

- id: po_approval_rate
  difficulty: moderate
  question: "Approval rate of purchase orders in {year}."
  evidence: "Use procurement_po_approvals; approved vs rejected."
  tables: [procurement_po_approvals]
  columns: [procurement_po_approvals.status, procurement_po_approvals.approval_date]
  tags: [procurement]
  gold_sql: |
    SELECT
      ROUND(100.0 * SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) / COUNT(*), 2) AS approval_pct
    FROM {schema}.procurement_po_approvals
    WHERE EXTRACT(YEAR FROM approval_date) = {year};

- id: rfq_response_time
  difficulty: challenging
  question: "Average days from RFQ to vendor response for {year}."
  evidence: "Join procurement_rfqs to procurement_rfq_responses."
  tables: [procurement_rfqs, procurement_rfq_responses]
  columns: [procurement_rfqs.rfq_date, procurement_rfq_responses.response_date]
  tags: [procurement, time]
  gold_sql: |
    SELECT ROUND(AVG(r.response_date - q.rfq_date), 2) AS avg_days
    FROM {schema}.procurement_rfqs q
    JOIN {schema}.procurement_rfq_responses r ON r.rfq_id = q.rfq_id
    WHERE EXTRACT(YEAR FROM q.rfq_date) = {year};

- id: inventory_qc_fail_rate
  difficulty: moderate
  question: "QC failure rate for inventory lots in {year}."
  evidence: "Fail results have result = 'fail'."
  tables: [inventory_qc_inspections, inventory_lots]
  columns: [inventory_qc_inspections.result, inventory_qc_inspections.inspection_date]
  tags: [inventory, qc]
  gold_sql: |
    SELECT
      ROUND(100.0 * SUM(CASE WHEN qi.result = 'fail' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_pct
    FROM {schema}.inventory_qc_inspections qi
    WHERE EXTRACT(YEAR FROM qi.inspection_date) = {year};

- id: inventory_lot_expiring
  difficulty: simple
  question: "List inventory lots expiring within 60 days."
  evidence: "Use inventory_lots.expiration_date."
  tables: [inventory_lots]
  columns: [inventory_lots.expiration_date, inventory_lots.lot_number]
  tags: [inventory]
  gold_sql: |
    SELECT lot_id, lot_number, expiration_date
    FROM {schema}.inventory_lots
    WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';

- id: time_clock_overtime
  difficulty: moderate
  question: "Employees with more than 10 time clock entries in a week during {year}."
  evidence: "Use hr_time_clock_entries.work_date; count per week."
  tables: [hr_time_clock_entries, employees]
  columns: [hr_time_clock_entries.work_date, employees.employee_id]
  tags: [hr, time]
  gold_sql: |
    SELECT e.employee_id, e.first_name, e.last_name, DATE_TRUNC('week', t.work_date) AS week_start, COUNT(*) AS entries
    FROM {schema}.hr_time_clock_entries t
    JOIN {schema}.employees e ON e.employee_id = t.employee_id
    WHERE EXTRACT(YEAR FROM t.work_date) = {year}
    GROUP BY e.employee_id, e.first_name, e.last_name, week_start
    HAVING COUNT(*) > 10;

- id: payroll_total
  difficulty: moderate
  question: "Total payroll net pay by pay period for {year}."
  evidence: "Payroll tables are payroll_run_hdr and payroll_run_line."
  tables: [payroll_run_hdr, payroll_run_line]
  columns: [payroll_run_hdr.pay_period_start, payroll_run_line.net_pay]
  tags: [hr, payroll]
  gold_sql: |
    SELECT h.pay_period_start, h.pay_period_end, SUM(l.net_pay) AS total_net_pay
    FROM {schema}.payroll_run_hdr h
    JOIN {schema}.payroll_run_line l ON l.run_id = h.run_id
    WHERE EXTRACT(YEAR FROM h.pay_period_start) = {year}
    GROUP BY h.pay_period_start, h.pay_period_end
    ORDER BY h.pay_period_start;

- id: benefit_election_rate
  difficulty: moderate
  question: "Benefit election count by coverage level in {year}."
  evidence: "Use hr_benefit_elections.election_date."
  tables: [hr_benefit_elections]
  columns: [hr_benefit_elections.coverage_level, hr_benefit_elections.election_date]
  tags: [hr, benefits]
  gold_sql: |
    SELECT coverage_level, COUNT(*) AS elections
    FROM {schema}.hr_benefit_elections
    WHERE EXTRACT(YEAR FROM election_date) = {year}
    GROUP BY coverage_level;

- id: onboarding_overdue
  difficulty: simple
  question: "Show onboarding tasks overdue as of today."
  evidence: "Overdue if status not done and due_date < today."
  tables: [hr_onboarding_tasks]
  columns: [hr_onboarding_tasks.status, hr_onboarding_tasks.due_date]
  tags: [hr]
  gold_sql: |
    SELECT task_id, employee_id, task_name, due_date, status
    FROM {schema}.hr_onboarding_tasks
    WHERE status <> 'done'
      AND due_date < CURRENT_DATE;

- id: sales_by_region
  difficulty: moderate
  question: "Sales order count by sales region for {year}."
  evidence: "Join sales_orders -> customers -> addresses -> cities -> states_provinces -> countries?" 
  tables: [sales_orders, customers, addresses, cities, states_provinces]
  columns: [sales_orders.order_date, customers.customer_id]
  tags: [sales, geography]
  gold_sql: |
    SELECT s.name AS state, COUNT(*) AS order_count
    FROM {schema}.sales_orders so
    JOIN {schema}.customers c ON c.customer_id = so.customer_id
    LEFT JOIN {schema}.addresses a ON a.address_id = c.billing_address_id
    LEFT JOIN {schema}.cities ci ON ci.city_id = a.city_id
    LEFT JOIN {schema}.states_provinces s ON s.state_id = ci.state_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY s.name
    ORDER BY order_count DESC;

- id: project_margin
  difficulty: challenging
  question: "Project margin = (budget - actual expenses) for active projects in {year}."
  evidence: "Use projects, project_budgets, project_expenses."
  tables: [projects, project_budgets, project_expenses]
  columns: [projects.status, project_budgets.planned_amount, project_expenses.amount]
  tags: [projects]
  gold_sql: |
    SELECT p.project_id, p.name,
           pb.planned_amount - COALESCE(SUM(pe.amount),0) AS margin
    FROM {schema}.projects p
    JOIN {schema}.project_budgets pb ON pb.project_id = p.project_id
    LEFT JOIN {schema}.project_expenses pe ON pe.project_id = p.project_id
    WHERE p.status = 'active'
      AND EXTRACT(YEAR FROM p.start_date) = {year}
    GROUP BY p.project_id, p.name, pb.planned_amount
    ORDER BY margin DESC;

- id: late_shipments
  difficulty: moderate
  question: "Sales orders shipped after ship_date in {year}."
  evidence: "Use sales_orders.ship_date and order_date; assume ship_date is planned date."
  tables: [sales_orders]
  columns: [sales_orders.ship_date, sales_orders.order_date]
  tags: [sales]
  gold_sql: |
    SELECT order_id, customer_id, order_date, ship_date
    FROM {schema}.sales_orders
    WHERE ship_date IS NOT NULL
      AND ship_date > order_date
      AND EXTRACT(YEAR FROM order_date) = {year};

- id: vendor_performance
  difficulty: challenging
  question: "Average days between PO order date and goods receipt for each vendor in {year}."
  evidence: "Join purchase_orders -> goods_receipts -> vendors."
  tables: [purchase_orders, goods_receipts, vendors]
  columns: [purchase_orders.order_date, goods_receipts.receipt_date, vendors.name]
  tags: [procurement]
  gold_sql: |
    SELECT v.name, ROUND(AVG(gr.receipt_date - po.order_date), 2) AS avg_days
    FROM {schema}.purchase_orders po
    JOIN {schema}.goods_receipts gr ON gr.po_id = po.po_id
    JOIN {schema}.vendors v ON v.vendor_id = po.vendor_id
    WHERE EXTRACT(YEAR FROM po.order_date) = {year}
    GROUP BY v.name
    ORDER BY avg_days;

- id: inventory_turns
  difficulty: challenging
  question: "Inventory turns by product category for {year}."
  evidence: "Approximate turns using inventory_transactions quantity."
  tables: [inventory_transactions, products, product_categories]
  columns: [inventory_transactions.quantity, inventory_transactions.transaction_date, product_categories.name]
  tags: [inventory]
  gold_sql: |
    SELECT pc.name, SUM(it.quantity) AS total_moved
    FROM {schema}.inventory_transactions it
    JOIN {schema}.products p ON p.product_id = it.product_id
    JOIN {schema}.product_categories pc ON pc.category_id = p.category_id
    WHERE EXTRACT(YEAR FROM it.transaction_date) = {year}
    GROUP BY pc.name
    ORDER BY total_moved DESC;

- id: sla_backlog
  difficulty: moderate
  question: "Count of open customer service cases by priority."
  evidence: "Use cust_srv_case; open/pending are not closed."
  tables: [cust_srv_case]
  columns: [cust_srv_case.status, cust_srv_case.priority]
  tags: [support]
  gold_sql: |
    SELECT priority, COUNT(*) AS case_count
    FROM {schema}.cust_srv_case
    WHERE status IN ('open','pending')
    GROUP BY priority;

- id: ticket_comment_volume
  difficulty: simple
  question: "Number of comments per support case in {year}."
  evidence: "Use support_ticket_comments.comment_ts."
  tables: [support_ticket_comments]
  columns: [support_ticket_comments.comment_ts]
  tags: [support]
  gold_sql: |
    SELECT case_id, COUNT(*) AS comment_count
    FROM {schema}.support_ticket_comments
    WHERE EXTRACT(YEAR FROM comment_ts) = {year}
    GROUP BY case_id;

- id: bank_balance
  difficulty: simple
  question: "List bank accounts with balance under {amount}."
  evidence: "Use bank_accounts.current_balance."
  tables: [bank_accounts]
  columns: [bank_accounts.current_balance]
  tags: [finance]
  gold_sql: |
    SELECT bank_account_id, account_number, bank_name, current_balance
    FROM {schema}.bank_accounts
    WHERE current_balance < {amount};

- id: budget_vs_actual
  difficulty: challenging
  question: "Departments where actual expenses exceed budget in {year}."
  evidence: "Compare project_expenses vs budgets by department."
  tables: [budgets, budget_lines, project_expenses, departments]
  columns: [budgets.total_amount, project_expenses.amount]
  tags: [finance, projects]
  gold_sql: |
    SELECT d.name, b.total_amount, COALESCE(SUM(pe.amount),0) AS actual_spend
    FROM {schema}.budgets b
    JOIN {schema}.departments d ON d.department_id = b.department_id
    LEFT JOIN {schema}.project_expenses pe ON pe.project_id IS NOT NULL
    WHERE EXTRACT(YEAR FROM b.created_at) = {year}
    GROUP BY d.name, b.total_amount
    HAVING COALESCE(SUM(pe.amount),0) > b.total_amount;

- id: open_opportunities
  difficulty: simple
  question: "List open sales opportunities with probability over {prob}."
  evidence: "Use sales_opportunities.probability."
  tables: [sales_opportunities]
  columns: [sales_opportunities.probability]
  tags: [sales]
  gold_sql: |
    SELECT opportunity_id, name, amount, probability
    FROM {schema}.sales_opportunities
    WHERE probability > {prob};

- id: quote_to_order_rate
  difficulty: challenging
  question: "Quote-to-order conversion rate for {year}."
  evidence: "Join sales_quotes to sales_orders by customer and dates."
  tables: [sales_quotes, sales_orders]
  columns: [sales_quotes.quote_date, sales_orders.order_date]
  tags: [sales]
  gold_sql: |
    SELECT
      ROUND(100.0 * COUNT(DISTINCT so.order_id) / NULLIF(COUNT(DISTINCT sq.quote_id),0), 2) AS conversion_pct
    FROM {schema}.sales_quotes sq
    LEFT JOIN {schema}.sales_orders so ON so.customer_id = sq.customer_id
    WHERE EXTRACT(YEAR FROM sq.quote_date) = {year};

- id: employee_utilization
  difficulty: challenging
  question: "Employee utilization rate = hours logged / 40 by week in {year}."
  evidence: "Use timesheet_entries.hours."
  tables: [timesheet_entries, timesheets, employees]
  columns: [timesheet_entries.hours, timesheets.week_start_date]
  tags: [projects, hr]
  gold_sql: |
    SELECT e.employee_id, DATE_TRUNC('week', t.week_start_date) AS week_start,
           ROUND(SUM(te.hours) / 40.0, 2) AS utilization
    FROM {schema}.timesheets t
    JOIN {schema}.timesheet_entries te ON te.timesheet_id = t.timesheet_id
    JOIN {schema}.employees e ON e.employee_id = t.employee_id
    WHERE EXTRACT(YEAR FROM t.week_start_date) = {year}
    GROUP BY e.employee_id, week_start;

- id: asset_maintenance_costs
  difficulty: moderate
  question: "Total maintenance cost by asset category in {year}."
  evidence: "Join asset_maintenance -> fixed_assets -> asset_categories."
  tables: [asset_maintenance, fixed_assets, asset_categories]
  columns: [asset_maintenance.cost, asset_categories.name]
  tags: [assets]
  gold_sql: |
    SELECT ac.name, SUM(am.cost) AS total_cost
    FROM {schema}.asset_maintenance am
    JOIN {schema}.fixed_assets fa ON fa.asset_id = am.asset_id
    JOIN {schema}.asset_categories ac ON ac.category_id = fa.category_id
    WHERE EXTRACT(YEAR FROM am.scheduled_date) = {year}
    GROUP BY ac.name;

- id: bank_tx_by_type
  difficulty: simple
  question: "Bank transaction totals by type for {year}."
  evidence: "Use bank_transactions.transaction_type."
  tables: [bank_transactions]
  columns: [bank_transactions.transaction_type, bank_transactions.amount, bank_transactions.transaction_date]
  tags: [finance]
  gold_sql: |
    SELECT transaction_type, SUM(amount) AS total_amount
    FROM {schema}.bank_transactions
    WHERE EXTRACT(YEAR FROM transaction_date) = {year}
    GROUP BY transaction_type;

- id: vendor_invoice_aging
  difficulty: moderate
  question: "Average days between vendor invoice date and due date by vendor."
  evidence: "Use vendor_invoices.invoice_date and due_date."
  tables: [vendor_invoices, vendors]
  columns: [vendor_invoices.invoice_date, vendor_invoices.due_date]
  tags: [procurement]
  gold_sql: |
    SELECT v.name, ROUND(AVG(vi.due_date - vi.invoice_date)::numeric, 2) AS avg_days
    FROM {schema}.vendor_invoices vi
    JOIN {schema}.vendors v ON v.vendor_id = vi.vendor_id
    GROUP BY v.name
    ORDER BY avg_days DESC;

- id: org_headcount
  difficulty: moderate
  question: "Headcount by department for {year}."
  evidence: "Use employees.department_id."
  tables: [employees, departments]
  columns: [employees.department_id]
  tags: [hr]
  gold_sql: |
    SELECT d.name, COUNT(*) AS headcount
    FROM {schema}.employees e
    JOIN {schema}.departments d ON d.department_id = e.department_id
    WHERE EXTRACT(YEAR FROM e.hire_date) <= {year}
    GROUP BY d.name
    ORDER BY headcount DESC;

- id: employee_turnover
  difficulty: challenging
  question: "Employee turnover rate for {year}."
  evidence: "Turnover = terminations / average headcount."
  tables: [employees]
  columns: [employees.termination_date, employees.hire_date]
  tags: [hr]
  gold_sql: |
    WITH terminations AS (
      SELECT COUNT(*) AS term_count
      FROM {schema}.employees
      WHERE EXTRACT(YEAR FROM termination_date) = {year}
    ),
    headcount AS (
      SELECT COUNT(*) AS headcount
      FROM {schema}.employees
      WHERE hire_date <= DATE '{year}-12-31'
        AND (termination_date IS NULL OR termination_date > DATE '{year}-01-01')
    )
    SELECT ROUND(100.0 * t.term_count / NULLIF(h.headcount,0), 2) AS turnover_pct
    FROM terminations t, headcount h;

- id: training_completion
  difficulty: moderate
  question: "Training completion rate by course for {year}."
  evidence: "Use employee_training.completion_date."
  tables: [training_courses, employee_training]
  columns: [employee_training.completion_date]
  tags: [hr, training]
  gold_sql: |
    SELECT c.name, COUNT(*) AS completions
    FROM {schema}.employee_training et
    JOIN {schema}.training_courses c ON c.course_id = et.course_id
    WHERE EXTRACT(YEAR FROM et.completion_date) = {year}
    GROUP BY c.name
    ORDER BY completions DESC;

- id: projects_over_budget
  difficulty: moderate
  question: "Projects where actual expenses exceed project budget."
  evidence: "Compare project_expenses to project_budgets."
  tables: [project_budgets, project_expenses, projects]
  columns: [project_budgets.planned_amount, project_expenses.amount]
  tags: [projects]
  gold_sql: |
    SELECT p.project_id, p.name
    FROM {schema}.projects p
    JOIN {schema}.project_budgets pb ON pb.project_id = p.project_id
    LEFT JOIN {schema}.project_expenses pe ON pe.project_id = p.project_id
    GROUP BY p.project_id, p.name, pb.planned_amount
    HAVING COALESCE(SUM(pe.amount),0) > pb.planned_amount;

- id: customer_credit_limit
  difficulty: simple
  question: "Customers with credit limit over {amount}."
  evidence: "Use customers.credit_limit."
  tables: [customers]
  columns: [customers.credit_limit]
  tags: [sales]
  gold_sql: |
    SELECT customer_id, name, credit_limit
    FROM {schema}.customers
    WHERE credit_limit > {amount};

- id: inventory_reorder
  difficulty: moderate
  question: "Products below reorder minimum by warehouse."
  evidence: "Join reorder_rules to inventory_levels."
  tables: [reorder_rules, inventory_levels, products]
  columns: [reorder_rules.min_quantity, inventory_levels.quantity_on_hand]
  tags: [inventory]
  gold_sql: |
    SELECT rr.warehouse_id, p.sku, il.quantity_on_hand, rr.min_quantity
    FROM {schema}.reorder_rules rr
    JOIN {schema}.inventory_levels il ON il.product_id = rr.product_id AND il.warehouse_id = rr.warehouse_id
    JOIN {schema}.products p ON p.product_id = rr.product_id
    WHERE il.quantity_on_hand < rr.min_quantity;

- id: sales_pipeline
  difficulty: moderate
  question: "Open opportunities by stage for {year}."
  evidence: "Join sales_opportunities to opportunity_stages."
  tables: [sales_opportunities, opportunity_stages]
  columns: [sales_opportunities.expected_close_date, opportunity_stages.name]
  tags: [sales]
  gold_sql: |
    SELECT os.name, COUNT(*) AS opportunity_count
    FROM {schema}.sales_opportunities so
    JOIN {schema}.opportunity_stages os ON os.stage_id = so.stage_id
    WHERE EXTRACT(YEAR FROM so.expected_close_date) = {year}
    GROUP BY os.name;

- id: journal_entry_volume
  difficulty: simple
  question: "Number of journal entries by month in {year}."
  evidence: "Use journal_entries.entry_date."
  tables: [journal_entries]
  columns: [journal_entries.entry_date]
  tags: [finance]
  gold_sql: |
    SELECT DATE_TRUNC('month', entry_date) AS month, COUNT(*) AS entry_count
    FROM {schema}.journal_entries
    WHERE EXTRACT(YEAR FROM entry_date) = {year}
    GROUP BY month
    ORDER BY month;

- id: vendor_spend_top
  difficulty: moderate
  question: "Top 5 vendors by total spend in {year}."
  evidence: "Use purchase_orders.total and vendor names."
  tables: [purchase_orders, vendors]
  columns: [purchase_orders.total, purchase_orders.order_date, vendors.name]
  tags: [procurement]
  gold_sql: |
    SELECT v.name, SUM(po.total) AS total_spend
    FROM {schema}.purchase_orders po
    JOIN {schema}.vendors v ON v.vendor_id = po.vendor_id
    WHERE EXTRACT(YEAR FROM po.order_date) = {year}
    GROUP BY v.name
    ORDER BY total_spend DESC
    LIMIT 5;

- id: asset_depreciation
  difficulty: moderate
  question: "Total depreciation by period for {year}."
  evidence: "Use depreciation_entries.period_id and amount."
  tables: [depreciation_entries, fiscal_periods]
  columns: [depreciation_entries.amount, fiscal_periods.start_date]
  tags: [assets, finance]
  gold_sql: |
    SELECT fp.start_date, SUM(de.amount) AS total_depr
    FROM {schema}.depreciation_entries de
    JOIN {schema}.fiscal_periods fp ON fp.period_id = de.period_id
    WHERE EXTRACT(YEAR FROM fp.start_date) = {year}
    GROUP BY fp.start_date
    ORDER BY fp.start_date;

- id: sales_order_discount
  difficulty: moderate
  question: "Average discount percentage on sales order lines in {year}."
  evidence: "discount is in order_lines.discount_percent."
  tables: [order_lines, sales_orders]
  columns: [order_lines.discount_percent, sales_orders.order_date]
  tags: [sales]
  gold_sql: |
    SELECT ROUND(AVG(ol.discount_percent), 2) AS avg_discount
    FROM {schema}.order_lines ol
    JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year};

- id: customer_service_sla
  difficulty: challenging
  question: "Average time to close support cases in {year}."
  evidence: "Closed cases have status = 'closed'; use opened_at vs updated_at."
  tables: [cust_srv_case]
  columns: [cust_srv_case.opened_at, cust_srv_case.updated_at]
  tags: [support]
  gold_sql: |
    SELECT ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - opened_at)) / 3600), 2) AS avg_close_hours
    FROM {schema}.cust_srv_case
    WHERE status = 'closed'
      AND EXTRACT(YEAR FROM opened_at) = {year};

- id: procurement_cycle_time
  difficulty: challenging
  question: "Average days from requisition to PO for {year}."
  evidence: "Join purchase_requisitions to purchase_orders by requisition_id."
  tables: [purchase_requisitions, purchase_orders]
  columns: [purchase_requisitions.request_date, purchase_orders.order_date]
  tags: [procurement]
  gold_sql: |
    SELECT ROUND(AVG(po.order_date - pr.request_date), 2) AS avg_days
    FROM {schema}.purchase_requisitions pr
    JOIN {schema}.purchase_orders po ON po.requisition_id = pr.requisition_id
    WHERE EXTRACT(YEAR FROM pr.request_date) = {year};

- id: inventory_adjustments
  difficulty: simple
  question: "Count inventory adjustments by reason in {year}."
  evidence: "Use inventory_adjustments.reason."
  tables: [inventory_adjustments]
  columns: [inventory_adjustments.reason, inventory_adjustments.adjustment_date]
  tags: [inventory]
  gold_sql: |
    SELECT reason, COUNT(*) AS adjustment_count
    FROM {schema}.inventory_adjustments
    WHERE EXTRACT(YEAR FROM adjustment_date) = {year}
    GROUP BY reason;

- id: project_resource_alloc
  difficulty: moderate
  question: "Average allocation percent by project in {year}."
  evidence: "Use project_resources.allocation_percent."
  tables: [project_resources, projects]
  columns: [project_resources.allocation_percent, projects.start_date]
  tags: [projects]
  gold_sql: |
    SELECT p.name, ROUND(AVG(pr.allocation_percent), 2) AS avg_alloc
    FROM {schema}.project_resources pr
    JOIN {schema}.projects p ON p.project_id = pr.project_id
    WHERE EXTRACT(YEAR FROM p.start_date) = {year}
    GROUP BY p.name;

- id: sales_order_status
  difficulty: simple
  question: "Sales order counts by status for {year}."
  evidence: "Use sales_orders.status."
  tables: [sales_orders]
  columns: [sales_orders.status, sales_orders.order_date]
  tags: [sales]
  gold_sql: |
    SELECT status, COUNT(*) AS order_count
    FROM {schema}.sales_orders
    WHERE EXTRACT(YEAR FROM order_date) = {year}
    GROUP BY status;

- id: vendor_active
  difficulty: simple
  question: "List inactive vendors."
  evidence: "Use vendors.is_active."
  tables: [vendors]
  columns: [vendors.is_active]
  tags: [procurement]
  gold_sql: |
    SELECT vendor_id, name
    FROM {schema}.vendors
    WHERE is_active = FALSE;

- id: cost_center_spend
  difficulty: moderate
  question: "Total journal line amounts by cost center for {year}."
  evidence: "Use journal_lines.debit and credit."
  tables: [journal_lines, cost_centers, journal_entries]
  columns: [journal_lines.debit, journal_lines.credit, journal_entries.entry_date]
  tags: [finance]
  gold_sql: |
    SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount
    FROM {schema}.journal_lines jl
    JOIN {schema}.journal_entries je ON je.entry_id = jl.entry_id
    JOIN {schema}.cost_centers cc ON cc.cost_center_id = jl.cost_center_id
    WHERE EXTRACT(YEAR FROM je.entry_date) = {year}
    GROUP BY cc.name;

- id: asset_transfer
  difficulty: moderate
  question: "Assets transferred between locations in {year}."
  evidence: "Use asset_transfers.transfer_date."
  tables: [asset_transfers]
  columns: [asset_transfers.transfer_date]
  tags: [assets]
  gold_sql: |
    SELECT transfer_id, asset_id, from_location_id, to_location_id, transfer_date
    FROM {schema}.asset_transfers
    WHERE EXTRACT(YEAR FROM transfer_date) = {year};

- id: supplier_terms
  difficulty: simple
  question: "Vendors with payment terms of {payment_terms} days or more."
  evidence: "Use vendors.payment_terms (integer, number of days)."
  tables: [vendors]
  columns: [vendors.payment_terms]
  tags: [procurement]
  gold_sql: |
    SELECT vendor_id, name, payment_terms
    FROM {schema}.vendors
    WHERE payment_terms >= {payment_terms};

- id: customer_contact_primary
  difficulty: simple
  question: "Primary contacts for all customers."
  evidence: "Join customers to customer_contacts where is_primary = TRUE."
  tables: [customers, customer_contacts]
  columns: [customer_contacts.is_primary, customer_contacts.first_name, customer_contacts.last_name]
  tags: [sales]
  gold_sql: |
    SELECT c.name AS customer, cc.first_name || ' ' || cc.last_name AS contact, cc.email
    FROM {schema}.customers c
    JOIN {schema}.customer_contacts cc ON cc.customer_id = c.customer_id
    WHERE cc.is_primary = TRUE
    ORDER BY c.name;

- id: warehouse_capacity
  difficulty: moderate
  question: "Warehouse locations with low capacity (< {capacity})."
  evidence: "Use warehouse_locations.capacity."
  tables: [warehouse_locations]
  columns: [warehouse_locations.capacity]
  tags: [inventory]
  gold_sql: |
    SELECT location_id, warehouse_id, aisle, rack, bin, capacity
    FROM {schema}.warehouse_locations
    WHERE capacity < {capacity};

- id: overdue_vendor_invoices
  difficulty: moderate
  question: "Vendor invoices past due as of today."
  evidence: "Use vendor_invoices.due_date and status."
  tables: [vendor_invoices]
  columns: [vendor_invoices.due_date, vendor_invoices.total]
  tags: [procurement]
  gold_sql: |
    SELECT invoice_id, vendor_id, due_date, total, status
    FROM {schema}.vendor_invoices
    WHERE due_date < CURRENT_DATE AND status <> 'paid';

- id: timesheet_approvals
  difficulty: simple
  question: "Timesheets awaiting approval in {year}."
  evidence: "Use timesheets.status = 'submitted'."
  tables: [timesheets]
  columns: [timesheets.status, timesheets.week_start_date]
  tags: [projects]
  gold_sql: |
    SELECT timesheet_id, employee_id, week_start_date, status
    FROM {schema}.timesheets
    WHERE status = 'submitted'
      AND EXTRACT(YEAR FROM week_start_date) = {year};

- id: expense_categories
  difficulty: moderate
  question: "Top expense categories for {year}."
  evidence: "Use project_expenses.category and amount."
  tables: [project_expenses]
  columns: [project_expenses.category, project_expenses.amount, project_expenses.expense_date]
  tags: [projects]
  gold_sql: |
    SELECT category, SUM(amount) AS total
    FROM {schema}.project_expenses
    WHERE EXTRACT(YEAR FROM expense_date) = {year}
    GROUP BY category
    ORDER BY total DESC;

# ============================================
# Phase 5: Harder exam questions
# ============================================

# --- Multi-step business logic (8) ---

- id: aged_ar_receivables
  difficulty: challenging
  question: "Aged AR receivables buckets (0-30, 31-60, 61-90, 90+) for {year}."
  evidence: "Use finance_ar_invoices with status='open'; age = CURRENT_DATE - due_date."
  tables: [finance_ar_invoices]
  columns: [finance_ar_invoices.due_date, finance_ar_invoices.amount, finance_ar_invoices.status]
  tags: [finance, ar, aging]
  gold_sql: |
    SELECT
      CASE
        WHEN CURRENT_DATE - due_date <= 30 THEN '0-30'
        WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'
        WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'
        ELSE '90+'
      END AS aging_bucket,
      COUNT(*) AS invoice_count,
      SUM(amount) AS total_amount
    FROM {schema}.finance_ar_invoices
    WHERE status = 'open'
      AND EXTRACT(YEAR FROM invoice_date) = {year}
    GROUP BY aging_bucket
    ORDER BY aging_bucket;

- id: dso_by_customer
  difficulty: challenging
  question: "Days Sales Outstanding (DSO) by customer for {year}."
  evidence: "DSO = (AR balance / total credit sales) * days in period. Approximate as avg days from invoice to payment."
  tables: [finance_ar_invoices, finance_ar_payments, customers]
  columns: [finance_ar_invoices.invoice_date, finance_ar_payments.payment_date, customers.name]
  tags: [finance, ar, kpi]
  gold_sql: |
    SELECT c.name,
           ROUND(AVG(p.payment_date - i.invoice_date), 1) AS avg_dso
    FROM {schema}.finance_ar_invoices i
    JOIN {schema}.finance_ar_payments p ON p.ar_invoice_id = i.ar_invoice_id
    JOIN {schema}.customers c ON c.customer_id = i.customer_id
    WHERE EXTRACT(YEAR FROM i.invoice_date) = {year}
    GROUP BY c.name
    ORDER BY avg_dso DESC;

- id: inventory_turnover_ratio
  difficulty: challenging
  question: "Inventory turnover ratio by product category for {year}."
  evidence: "Turnover = total units moved / average quantity on hand. Use inventory_transactions for movement."
  tables: [inventory_transactions, products, product_categories, inventory_levels]
  columns: [inventory_transactions.quantity, inventory_transactions.transaction_date, product_categories.name]
  tags: [inventory, kpi]
  gold_sql: |
    SELECT pc.name,
           SUM(ABS(it.quantity)) AS total_moved,
           AVG(il.quantity_on_hand) AS avg_on_hand,
           ROUND(SUM(ABS(it.quantity)) / NULLIF(AVG(il.quantity_on_hand), 0), 2) AS turnover_ratio
    FROM {schema}.inventory_transactions it
    JOIN {schema}.products p ON p.product_id = it.product_id
    JOIN {schema}.product_categories pc ON pc.category_id = p.category_id
    LEFT JOIN {schema}.inventory_levels il ON il.product_id = p.product_id
    WHERE EXTRACT(YEAR FROM it.transaction_date) = {year}
    GROUP BY pc.name
    ORDER BY turnover_ratio DESC;

- id: budget_variance_dept
  difficulty: challenging
  question: "Budget variance (planned vs actual) by department for {year}."
  evidence: "Use budgets for planned and project_expenses for actual; join via department_id on budgets."
  tables: [budgets, departments, project_expenses]
  columns: [budgets.total_amount, project_expenses.amount, departments.name]
  tags: [finance, budget]
  gold_sql: |
    SELECT d.name,
           b.total_amount AS planned,
           COALESCE(SUM(pe.amount), 0) AS actual,
           b.total_amount - COALESCE(SUM(pe.amount), 0) AS variance
    FROM {schema}.budgets b
    JOIN {schema}.departments d ON d.department_id = b.department_id
    LEFT JOIN {schema}.project_expenses pe ON pe.project_id IN (
      SELECT project_id FROM {schema}.projects WHERE customer_id IS NOT NULL
    ) AND EXTRACT(YEAR FROM pe.expense_date) = {year}
    WHERE EXTRACT(YEAR FROM b.created_at) = {year}
    GROUP BY d.name, b.total_amount
    ORDER BY variance;

- id: vendor_payment_cycle
  difficulty: challenging
  question: "Average vendor payment cycle (invoice to payment) by vendor for {year}."
  evidence: "Join finance_ap_invoices to vendor_payments by vendor."
  tables: [finance_ap_invoices, vendors]
  columns: [finance_ap_invoices.invoice_date, finance_ap_invoices.due_date, vendors.name]
  tags: [procurement, kpi]
  gold_sql: |
    SELECT v.name,
           ROUND(AVG(ai.due_date - ai.invoice_date), 1) AS avg_payment_cycle_days,
           COUNT(*) AS invoice_count
    FROM {schema}.finance_ap_invoices ai
    JOIN {schema}.vendors v ON v.vendor_id = ai.vendor_id
    WHERE EXTRACT(YEAR FROM ai.invoice_date) = {year}
    GROUP BY v.name
    ORDER BY avg_payment_cycle_days DESC;

- id: employee_cost_per_dept
  difficulty: challenging
  question: "Total employee cost (gross pay) per department for {year}."
  evidence: "Join payroll_run_line to employees to departments."
  tables: [payroll_run_line, payroll_run_hdr, employees, departments]
  columns: [payroll_run_line.gross_pay, employees.department_id, departments.name]
  tags: [hr, finance]
  gold_sql: |
    SELECT d.name,
           SUM(prl.gross_pay) AS total_cost,
           COUNT(DISTINCT prl.employee_id) AS employee_count
    FROM {schema}.payroll_run_line prl
    JOIN {schema}.payroll_run_hdr prh ON prh.run_id = prl.run_id
    JOIN {schema}.employees e ON e.employee_id = prl.employee_id
    JOIN {schema}.departments d ON d.department_id = e.department_id
    WHERE EXTRACT(YEAR FROM prh.pay_period_start) = {year}
    GROUP BY d.name
    ORDER BY total_cost DESC;

- id: gross_margin_by_product
  difficulty: challenging
  question: "Gross margin (revenue - COGS estimate) by product for {year}."
  evidence: "Revenue from order_lines; COGS approximated by list_price * 0.6."
  tables: [order_lines, sales_orders, products]
  columns: [order_lines.quantity, order_lines.unit_price, products.name]
  tags: [sales, finance, kpi]
  gold_sql: |
    SELECT p.name,
           SUM(ol.quantity * ol.unit_price) AS revenue,
           SUM(ol.quantity * ol.unit_price * 0.6) AS estimated_cogs,
           ROUND(SUM(ol.quantity * ol.unit_price * 0.4), 2) AS gross_margin
    FROM {schema}.order_lines ol
    JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
    JOIN {schema}.products p ON p.product_id = ol.product_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY p.name
    ORDER BY gross_margin DESC
    LIMIT 20;

- id: cogs_by_product
  difficulty: challenging
  question: "Cost of goods sold by product line for {year}."
  evidence: "COGS = quantity sold * list_price * cost_ratio (approximate)."
  tables: [order_lines, sales_orders, products, product_categories]
  columns: [order_lines.quantity, order_lines.unit_price, product_categories.name]
  tags: [finance, kpi]
  gold_sql: |
    SELECT pc.name AS product_line,
           SUM(ol.quantity * ol.unit_price) AS total_revenue,
           COUNT(DISTINCT so.order_id) AS order_count
    FROM {schema}.order_lines ol
    JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
    JOIN {schema}.products p ON p.product_id = ol.product_id
    JOIN {schema}.product_categories pc ON pc.category_id = p.category_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY pc.name
    ORDER BY total_revenue DESC;

# --- Temporal (5) ---

- id: yoy_sales_growth
  difficulty: challenging
  question: "Year-over-year sales growth comparing {year} to the prior year."
  evidence: "Compare total order line amounts between two consecutive years."
  tables: [order_lines, sales_orders]
  columns: [order_lines.quantity, order_lines.unit_price, sales_orders.order_date]
  tags: [sales, temporal]
  gold_sql: |
    WITH yearly AS (
      SELECT EXTRACT(YEAR FROM so.order_date) AS yr,
             SUM(ol.quantity * ol.unit_price) AS total_sales
      FROM {schema}.order_lines ol
      JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
      WHERE EXTRACT(YEAR FROM so.order_date) IN ({year}, {year} - 1)
      GROUP BY yr
    )
    SELECT
      cur.total_sales AS current_year_sales,
      prev.total_sales AS prior_year_sales,
      ROUND(100.0 * (cur.total_sales - prev.total_sales) / NULLIF(prev.total_sales, 0), 2) AS growth_pct
    FROM yearly cur
    JOIN yearly prev ON cur.yr = prev.yr + 1;

- id: monthly_ar_trend
  difficulty: challenging
  question: "Monthly AR invoice trend with running total for {year}."
  evidence: "Use window function SUM() OVER for running total."
  tables: [finance_ar_invoices]
  columns: [finance_ar_invoices.invoice_date, finance_ar_invoices.amount]
  tags: [finance, temporal, window]
  gold_sql: |
    SELECT
      DATE_TRUNC('month', invoice_date) AS month,
      SUM(amount) AS monthly_amount,
      SUM(SUM(amount)) OVER (ORDER BY DATE_TRUNC('month', invoice_date)) AS running_total
    FROM {schema}.finance_ar_invoices
    WHERE EXTRACT(YEAR FROM invoice_date) = {year}
    GROUP BY month
    ORDER BY month;

- id: employee_tenure_distribution
  difficulty: challenging
  question: "Employee tenure distribution (0-1yr, 1-3yr, 3-5yr, 5+yr) as of {year}."
  evidence: "Tenure = hire_date to end of year; bucket by years."
  tables: [employees]
  columns: [employees.hire_date]
  tags: [hr, temporal]
  gold_sql: |
    SELECT
      CASE
        WHEN EXTRACT(YEAR FROM AGE(DATE '{year}-12-31', hire_date)) < 1 THEN '0-1 yr'
        WHEN EXTRACT(YEAR FROM AGE(DATE '{year}-12-31', hire_date)) < 3 THEN '1-3 yr'
        WHEN EXTRACT(YEAR FROM AGE(DATE '{year}-12-31', hire_date)) < 5 THEN '3-5 yr'
        ELSE '5+ yr'
      END AS tenure_bucket,
      COUNT(*) AS employee_count
    FROM {schema}.employees
    WHERE hire_date <= DATE '{year}-12-31'
      AND (termination_date IS NULL OR termination_date > DATE '{year}-12-31')
    GROUP BY tenure_bucket
    ORDER BY tenure_bucket;

- id: quarterly_revenue
  difficulty: moderate
  question: "Quarterly revenue comparison for {year}."
  evidence: "Revenue = sum of order_lines.quantity * unit_price by quarter."
  tables: [order_lines, sales_orders]
  columns: [order_lines.quantity, order_lines.unit_price, sales_orders.order_date]
  tags: [sales, temporal]
  gold_sql: |
    SELECT
      EXTRACT(QUARTER FROM so.order_date) AS quarter,
      SUM(ol.quantity * ol.unit_price) AS revenue
    FROM {schema}.order_lines ol
    JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY quarter
    ORDER BY quarter;

- id: pop_headcount_change
  difficulty: challenging
  question: "Period-over-period headcount change by month for {year}."
  evidence: "Count active employees at end of each month."
  tables: [employees]
  columns: [employees.hire_date, employees.termination_date]
  tags: [hr, temporal]
  gold_sql: |
    WITH months AS (
      SELECT generate_series(1, 12) AS month_num
    ),
    headcount AS (
      SELECT m.month_num,
             COUNT(*) AS hc
      FROM months m
      JOIN {schema}.employees e ON e.hire_date <= DATE '{year}-12-31'
        AND (DATE '{year}-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date
        AND (e.termination_date IS NULL
             OR e.termination_date > DATE '{year}-01-01' + (m.month_num - 1) * INTERVAL '1 month')
      GROUP BY m.month_num
    )
    SELECT month_num, hc,
           hc - LAG(hc) OVER (ORDER BY month_num) AS change
    FROM headcount
    ORDER BY month_num;

# --- Domain jargon (4) ---

- id: fte_headcount
  difficulty: moderate
  question: "FTE headcount by department for {year}."
  evidence: "FTE = full-time equivalent; count employees active during the year."
  tables: [employees, departments]
  columns: [employees.department_id, employees.hire_date]
  tags: [hr, jargon]
  gold_sql: |
    SELECT d.name AS department,
           COUNT(*) AS fte_count
    FROM {schema}.employees e
    JOIN {schema}.departments d ON d.department_id = e.department_id
    WHERE e.hire_date <= DATE '{year}-12-31'
      AND (e.termination_date IS NULL OR e.termination_date > DATE '{year}-01-01')
    GROUP BY d.name
    ORDER BY fte_count DESC;

- id: weighted_avg_cost
  difficulty: challenging
  question: "Weighted average cost per unit by product for {year}."
  evidence: "Weighted avg = sum(qty * unit_price) / sum(qty) from order lines."
  tables: [order_lines, sales_orders, products]
  columns: [order_lines.quantity, order_lines.unit_price, products.name]
  tags: [finance, jargon]
  gold_sql: |
    SELECT p.name,
           ROUND(SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0), 2) AS weighted_avg_cost,
           SUM(ol.quantity) AS total_units
    FROM {schema}.order_lines ol
    JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
    JOIN {schema}.products p ON p.product_id = ol.product_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY p.name
    ORDER BY weighted_avg_cost DESC;

- id: working_capital_ratio
  difficulty: challenging
  question: "Working capital ratio: current assets (AR) vs current liabilities (AP) for {year}."
  evidence: "Working capital = AR open amounts / AP open amounts."
  tables: [finance_ar_invoices, finance_ap_invoices]
  columns: [finance_ar_invoices.amount, finance_ap_invoices.amount]
  tags: [finance, jargon]
  gold_sql: |
    WITH ar AS (
      SELECT SUM(amount) AS total_ar
      FROM {schema}.finance_ar_invoices
      WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = {year}
    ),
    ap AS (
      SELECT SUM(amount) AS total_ap
      FROM {schema}.finance_ap_invoices
      WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = {year}
    )
    SELECT ar.total_ar, ap.total_ap,
           ROUND(ar.total_ar / NULLIF(ap.total_ap, 0), 2) AS working_capital_ratio
    FROM ar, ap;

- id: revenue_per_fte
  difficulty: challenging
  question: "Revenue per FTE by department for {year}."
  evidence: "Revenue from sales; FTE from employee count. Join via sales_rep or department."
  tables: [order_lines, sales_orders, employees, departments]
  columns: [order_lines.quantity, order_lines.unit_price, employees.department_id]
  tags: [sales, hr, jargon]
  gold_sql: |
    WITH dept_revenue AS (
      SELECT e.department_id,
             SUM(ol.quantity * ol.unit_price) AS revenue
      FROM {schema}.order_lines ol
      JOIN {schema}.sales_orders so ON so.order_id = ol.order_id
      JOIN {schema}.employees e ON e.employee_id = so.sales_rep_id
      WHERE EXTRACT(YEAR FROM so.order_date) = {year}
      GROUP BY e.department_id
    ),
    dept_fte AS (
      SELECT department_id, COUNT(*) AS fte
      FROM {schema}.employees
      WHERE hire_date <= DATE '{year}-12-31'
        AND (termination_date IS NULL OR termination_date > DATE '{year}-01-01')
      GROUP BY department_id
    )
    SELECT d.name,
           dr.revenue,
           df.fte,
           ROUND(dr.revenue / NULLIF(df.fte, 0), 2) AS revenue_per_fte
    FROM dept_revenue dr
    JOIN dept_fte df ON df.department_id = dr.department_id
    JOIN {schema}.departments d ON d.department_id = dr.department_id
    ORDER BY revenue_per_fte DESC;

# --- 5-7 table joins (4) ---

- id: order_to_cash_cycle
  difficulty: challenging
  question: "Order-to-cash cycle: customer, order, lines, AR invoice, payment for {year}."
  evidence: "5-table join: customers -> sales_orders -> order_lines -> finance_ar_invoices -> finance_ar_payments."
  tables: [customers, sales_orders, order_lines, finance_ar_invoices, finance_ar_payments]
  columns: [customers.name, sales_orders.order_date, finance_ar_payments.payment_date]
  tags: [sales, finance, multi_join]
  gold_sql: |
    SELECT c.name AS customer,
           so.order_id,
           SUM(ol.quantity * ol.unit_price) AS order_total,
           ar.invoice_number,
           ar.amount AS invoice_amount,
           p.payment_date,
           p.amount AS payment_amount
    FROM {schema}.customers c
    JOIN {schema}.sales_orders so ON so.customer_id = c.customer_id
    JOIN {schema}.order_lines ol ON ol.order_id = so.order_id
    JOIN {schema}.finance_ar_invoices ar ON ar.customer_id = c.customer_id
    LEFT JOIN {schema}.finance_ar_payments p ON p.ar_invoice_id = ar.ar_invoice_id
    WHERE EXTRACT(YEAR FROM so.order_date) = {year}
    GROUP BY c.name, so.order_id, ar.invoice_number, ar.amount, p.payment_date, p.amount
    LIMIT 50;

- id: procure_to_pay_cycle
  difficulty: challenging
  question: "Procure-to-pay cycle: PO to receipt to invoice for each vendor in {year}."
  evidence: "Join purchase_orders -> goods_receipts -> vendor_invoices -> vendors."
  tables: [purchase_orders, goods_receipts, vendor_invoices, vendors]
  columns: [purchase_orders.order_date, goods_receipts.receipt_date, vendor_invoices.invoice_date]
  tags: [procurement, multi_join]
  gold_sql: |
    SELECT v.name AS vendor,
           po.po_id,
           po.order_date,
           gr.receipt_id,
           gr.receipt_date,
           vi.invoice_id,
           vi.invoice_date,
           vi.total AS invoice_total
    FROM {schema}.purchase_orders po
    JOIN {schema}.goods_receipts gr ON gr.po_id = po.po_id
    JOIN {schema}.vendor_invoices vi ON vi.po_id = po.po_id
    JOIN {schema}.vendors v ON v.vendor_id = po.vendor_id
    WHERE EXTRACT(YEAR FROM po.order_date) = {year}
    ORDER BY po.order_date
    LIMIT 50;

- id: project_profitability_full
  difficulty: challenging
  question: "Project profitability: budget vs actual with milestones and timesheets for {year}."
  evidence: "Join projects -> project_budgets -> project_expenses -> timesheets -> timesheet_entries."
  tables: [projects, project_budgets, project_expenses, timesheets, timesheet_entries]
  columns: [project_budgets.planned_amount, project_expenses.amount, timesheet_entries.hours]
  tags: [projects, multi_join]
  gold_sql: |
    SELECT p.name,
           pb.planned_amount AS budget,
           COALESCE(SUM(DISTINCT pe.amount), 0) AS total_expenses,
           COALESCE(SUM(te.hours), 0) AS total_hours,
           pb.planned_amount - COALESCE(SUM(DISTINCT pe.amount), 0) AS profit_margin
    FROM {schema}.projects p
    JOIN {schema}.project_budgets pb ON pb.project_id = p.project_id
    LEFT JOIN {schema}.project_expenses pe ON pe.project_id = p.project_id
    LEFT JOIN {schema}.timesheets ts ON ts.employee_id IN (
      SELECT employee_id FROM {schema}.project_resources WHERE project_id = p.project_id
    )
    LEFT JOIN {schema}.timesheet_entries te ON te.timesheet_id = ts.timesheet_id
    WHERE EXTRACT(YEAR FROM p.start_date) = {year}
    GROUP BY p.name, pb.planned_amount
    ORDER BY profit_margin DESC;

- id: complete_employee_profile
  difficulty: challenging
  question: "Complete employee profile: department, position, salary, benefits, certifications for {year}."
  evidence: "Join employees -> departments -> positions -> employee_salaries -> hr_benefit_elections -> employee_certifications."
  tables: [employees, departments, positions, employee_salaries, hr_benefit_elections, employee_certifications]
  columns: [employees.first_name, employees.last_name, departments.name, employee_salaries.salary]
  tags: [hr, multi_join]
  gold_sql: |
    SELECT e.first_name, e.last_name,
           d.name AS department,
           pos.title AS position,
           es.amount AS salary,
           COUNT(DISTINCT be.election_id) AS benefit_elections,
           COUNT(DISTINCT ec.certification_id) AS certifications
    FROM {schema}.employees e
    JOIN {schema}.departments d ON d.department_id = e.department_id
    LEFT JOIN {schema}.positions pos ON pos.position_id = e.position_id
    LEFT JOIN {schema}.employee_salaries es ON es.employee_id = e.employee_id
      AND es.effective_date <= DATE '{year}-12-31'
    LEFT JOIN {schema}.hr_benefit_elections be ON be.employee_id = e.employee_id
      AND EXTRACT(YEAR FROM be.election_date) = {year}
    LEFT JOIN {schema}.employee_certifications ec ON ec.employee_id = e.employee_id
    GROUP BY e.first_name, e.last_name, d.name, pos.title, es.amount
    LIMIT 50;

# --- Coded lookup queries (4) ---

- id: wo_status_decoded
  difficulty: moderate
  question: "Work order count by decoded status in manufacturing division {schema}."
  evidence: "Join mfg_work_orders.status_code to lookup_codes where domain='WO_STATUS'."
  tables: [mfg_work_orders, lookup_codes]
  columns: [mfg_work_orders.status_code, lookup_codes.meaning]
  tags: [manufacturing, lookup]
  archetype: manufacturing
  gold_sql: |
    SELECT lc.meaning AS status,
           COUNT(*) AS wo_count
    FROM {schema}.mfg_work_orders wo
    JOIN {schema}.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'
    GROUP BY lc.meaning
    ORDER BY wo_count DESC;

- id: approval_status_decoded
  difficulty: moderate
  question: "Workflow approval counts by decoded approval status."
  evidence: "Join wf_approval_step.status to lookup_codes where domain='APPROVAL_STATUS'. Note: status values may be 'pending','approved','rejected' (text) not codes."
  tables: [wf_approval_step, lookup_codes]
  columns: [wf_approval_step.status, lookup_codes.meaning]
  tags: [workflow, lookup]
  gold_sql: |
    SELECT status, COUNT(*) AS step_count
    FROM {schema}.wf_approval_step
    GROUP BY status
    ORDER BY step_count DESC;

- id: priority_filter_decoded
  difficulty: moderate
  question: "High and critical priority work orders using lookup codes in {schema}."
  evidence: "Filter mfg_work_orders.priority_code via lookup_codes domain='PRIORITY' where meaning IN ('High','Critical')."
  tables: [mfg_work_orders, lookup_codes]
  columns: [mfg_work_orders.priority_code, lookup_codes.meaning]
  tags: [manufacturing, lookup]
  archetype: manufacturing
  gold_sql: |
    SELECT wo.work_order_id, wo.work_order_number, lc.meaning AS priority
    FROM {schema}.mfg_work_orders wo
    JOIN {schema}.lookup_codes lc ON lc.code = wo.priority_code AND lc.domain = 'PRIORITY'
    WHERE lc.meaning IN ('High', 'Critical');

- id: scrap_by_reason_decoded
  difficulty: moderate
  question: "Total scrap quantity by reason for manufacturing division {schema}."
  evidence: "Use mfg_scrap_log; reason_code values are abbreviations like DM, OP, EQ, MT."
  tables: [mfg_scrap_log]
  columns: [mfg_scrap_log.reason_code, mfg_scrap_log.scrap_quantity]
  tags: [manufacturing]
  archetype: manufacturing
  gold_sql: |
    SELECT reason_code, SUM(scrap_quantity) AS total_scrap
    FROM {schema}.mfg_scrap_log
    GROUP BY reason_code
    ORDER BY total_scrap DESC;

# ============================================
# Services archetype templates
# ============================================

- id: svc_sow_by_status
  difficulty: moderate
  question: "Count of statements of work by status for services division {schema}."
  evidence: "Join svc_statements_of_work.status_code to lookup_codes domain='PROJECT_STATUS' for decoded names."
  tables: [svc_statements_of_work, lookup_codes]
  columns: [svc_statements_of_work.status_code, lookup_codes.meaning]
  tags: [services, lookup]
  archetype: services
  gold_sql: |
    SELECT lc.meaning AS status, COUNT(*) AS sow_count
    FROM {schema}.svc_statements_of_work sow
    JOIN {schema}.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'
    GROUP BY lc.meaning
    ORDER BY sow_count DESC;

- id: svc_revenue_by_customer
  difficulty: challenging
  question: "Total SOW contract value by customer for services division {schema}."
  evidence: "Sum svc_statements_of_work.total_amount grouped by customer_id, join to customers."
  tables: [svc_statements_of_work, customers]
  columns: [svc_statements_of_work.total_amount, svc_statements_of_work.customer_id, customers.name]
  tags: [services]
  archetype: services
  gold_sql: |
    SELECT c.name, SUM(sow.total_amount) AS total_contract_value, COUNT(*) AS sow_count
    FROM {schema}.svc_statements_of_work sow
    JOIN {schema}.customers c ON c.customer_id = sow.customer_id
    GROUP BY c.name
    ORDER BY total_contract_value DESC
    LIMIT 10;

- id: svc_resource_utilization
  difficulty: challenging
  question: "Average resource allocation percent by role for active SOWs in services division {schema}."
  evidence: "Join svc_resource_plan to svc_statements_of_work; filter active SOWs (status_code='AC')."
  tables: [svc_resource_plan, svc_statements_of_work]
  columns: [svc_resource_plan.role_name, svc_resource_plan.allocation_percent, svc_statements_of_work.status_code]
  tags: [services, kpi]
  archetype: services
  gold_sql: |
    SELECT rp.role_name,
           ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,
           COUNT(*) AS assignments
    FROM {schema}.svc_resource_plan rp
    JOIN {schema}.svc_statements_of_work sow ON sow.sow_id = rp.sow_id
    WHERE sow.status_code = 'AC'
    GROUP BY rp.role_name
    ORDER BY avg_allocation DESC;

- id: svc_overdue_milestones
  difficulty: moderate
  question: "Billing milestones past due and not yet invoiced for services division {schema}."
  evidence: "svc_billing_milestones where due_date < today and invoice_date IS NULL."
  tables: [svc_billing_milestones, svc_statements_of_work]
  columns: [svc_billing_milestones.due_date, svc_billing_milestones.invoice_date, svc_billing_milestones.amount]
  tags: [services]
  archetype: services
  gold_sql: |
    SELECT sow.sow_number, bm.description, bm.amount, bm.due_date
    FROM {schema}.svc_billing_milestones bm
    JOIN {schema}.svc_statements_of_work sow ON sow.sow_id = bm.sow_id
    WHERE bm.due_date < CURRENT_DATE AND bm.invoice_date IS NULL
    ORDER BY bm.due_date;

# ============================================
# Retail archetype templates
# ============================================

- id: rtl_sales_by_payment_method
  difficulty: moderate
  question: "Total POS sales by payment method for retail division {schema}."
  evidence: "Use rtl_pos_transactions; payment_method_code values: CASH, CC, DC, GC, MW."
  tables: [rtl_pos_transactions]
  columns: [rtl_pos_transactions.payment_method_code, rtl_pos_transactions.total_amount]
  tags: [retail]
  archetype: retail
  gold_sql: |
    SELECT payment_method_code, COUNT(*) AS txn_count,
           SUM(total_amount) AS total_sales
    FROM {schema}.rtl_pos_transactions
    GROUP BY payment_method_code
    ORDER BY total_sales DESC;

- id: rtl_loyalty_tier_distribution
  difficulty: moderate
  question: "Loyalty member count by tier for retail division {schema}."
  evidence: "Use rtl_loyalty_members; tier_code values: BZ (Bronze), SV (Silver), GD (Gold), PT (Platinum)."
  tables: [rtl_loyalty_members]
  columns: [rtl_loyalty_members.tier_code, rtl_loyalty_members.status_code]
  tags: [retail, lookup]
  archetype: retail
  gold_sql: |
    SELECT tier_code, COUNT(*) AS member_count,
           AVG(points_balance) AS avg_points
    FROM {schema}.rtl_loyalty_members
    WHERE status_code = 'AC'
    GROUP BY tier_code
    ORDER BY member_count DESC;

- id: rtl_top_products_by_revenue
  difficulty: challenging
  question: "Top 10 products by POS revenue for retail division {schema}."
  evidence: "Join rtl_pos_line_items to products via product_id. Revenue = line_total."
  tables: [rtl_pos_line_items, products]
  columns: [rtl_pos_line_items.line_total, products.name]
  tags: [retail]
  archetype: retail
  gold_sql: |
    SELECT p.name, SUM(li.line_total) AS total_revenue,
           SUM(li.quantity) AS units_sold
    FROM {schema}.rtl_pos_line_items li
    JOIN {schema}.products p ON p.product_id = li.product_id
    GROUP BY p.name
    ORDER BY total_revenue DESC
    LIMIT 10;

- id: rtl_promotion_effectiveness
  difficulty: challenging
  question: "Promotion effectiveness: average discount and transaction count per active promotion for {schema}."
  evidence: "Join rtl_pos_line_items.promotion_code to rtl_promotions.promotion_code; only active promos."
  tables: [rtl_pos_line_items, rtl_promotions]
  columns: [rtl_pos_line_items.discount_amount, rtl_promotions.promotion_code, rtl_promotions.status_code]
  tags: [retail]
  archetype: retail
  gold_sql: |
    SELECT pr.promotion_name, pr.discount_type_code,
           COUNT(*) AS line_items,
           ROUND(AVG(li.discount_amount), 2) AS avg_discount
    FROM {schema}.rtl_pos_line_items li
    JOIN {schema}.rtl_promotions pr ON pr.promotion_code = li.promotion_code
    WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL
    GROUP BY pr.promotion_name, pr.discount_type_code
    ORDER BY line_items DESC;

# ============================================
# Corporate archetype templates
# ============================================

- id: corp_intercompany_balance
  difficulty: challenging
  question: "Net intercompany balance between divisions for corporate division {schema}."
  evidence: "Use corp_intercompany_txns; net = sum sent - sum received per division pair."
  tables: [corp_intercompany_txns]
  columns: [corp_intercompany_txns.from_division, corp_intercompany_txns.to_division, corp_intercompany_txns.amount]
  tags: [corporate]
  archetype: corporate
  gold_sql: |
    SELECT from_division, to_division,
           SUM(amount) AS total_transferred,
           COUNT(*) AS txn_count
    FROM {schema}.corp_intercompany_txns
    WHERE status_code = 'AP'
    GROUP BY from_division, to_division
    ORDER BY total_transferred DESC;

- id: corp_consolidation_by_currency
  difficulty: challenging
  question: "Consolidation totals by currency with FX impact for corporate division {schema}."
  evidence: "Use corp_consolidation_entries; FX impact = translated_amount - original_amount."
  tables: [corp_consolidation_entries]
  columns: [corp_consolidation_entries.currency_code, corp_consolidation_entries.original_amount, corp_consolidation_entries.translated_amount]
  tags: [corporate]
  archetype: corporate
  gold_sql: |
    SELECT currency_code,
           SUM(original_amount) AS total_original,
           SUM(translated_amount) AS total_translated,
           SUM(translated_amount - original_amount) AS fx_impact,
           COUNT(*) AS entry_count
    FROM {schema}.corp_consolidation_entries
    GROUP BY currency_code
    ORDER BY total_original DESC;

- id: corp_tax_effective_vs_statutory
  difficulty: challenging
  question: "Compare effective vs statutory tax rate by jurisdiction for corporate division {schema}."
  evidence: "Use corp_tax_provisions; compare effective_rate to statutory_rate."
  tables: [corp_tax_provisions]
  columns: [corp_tax_provisions.jurisdiction, corp_tax_provisions.effective_rate, corp_tax_provisions.statutory_rate]
  tags: [corporate]
  archetype: corporate
  gold_sql: |
    SELECT jurisdiction, tax_type,
           ROUND(AVG(effective_rate), 4) AS avg_effective_rate,
           ROUND(AVG(statutory_rate), 4) AS avg_statutory_rate,
           ROUND(AVG(statutory_rate - effective_rate), 4) AS avg_rate_gap,
           SUM(current_provision + deferred_provision) AS total_provision
    FROM {schema}.corp_tax_provisions
    GROUP BY jurisdiction, tax_type
    ORDER BY total_provision DESC;

- id: corp_audit_findings_open
  difficulty: moderate
  question: "Open audit findings by severity and type for corporate division {schema}."
  evidence: "Use corp_audit_findings where status_code IN ('OP','IP')."
  tables: [corp_audit_findings]
  columns: [corp_audit_findings.severity, corp_audit_findings.audit_type, corp_audit_findings.status_code]
  tags: [corporate]
  archetype: corporate
  gold_sql: |
    SELECT audit_type, severity, COUNT(*) AS finding_count
    FROM {schema}.corp_audit_findings
    WHERE status_code IN ('OP', 'IP')
    GROUP BY audit_type, severity
    ORDER BY severity, finding_count DESC;

# ============================================
# Dirty naming templates (abbreviated columns)
# ============================================

- id: dirty_mfg_wo_status
  difficulty: challenging
  question: "Work order count by decoded status in manufacturing division {schema}."
  evidence: "Table is xx_mfg_wo with abbreviated columns: sts_cd for status. Join to lookup_codes domain='WO_STATUS'."
  tables: [xx_mfg_wo, lookup_codes]
  columns: [xx_mfg_wo.sts_cd, lookup_codes.meaning]
  tags: [manufacturing, dirty_naming, lookup]
  archetype: manufacturing
  gold_sql: |
    SELECT lc.meaning AS status, COUNT(*) AS wo_count
    FROM {schema}.xx_mfg_wo wo
    JOIN {schema}.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'
    GROUP BY lc.meaning
    ORDER BY wo_count DESC;

- id: dirty_svc_sow_value
  difficulty: challenging
  question: "Total contract value by customer for services division {schema}."
  evidence: "Table is zz_svc_sow with abbreviated columns: tot_amt for total amount, cust_nbr for customer ID. Join to customers."
  tables: [zz_svc_sow, customers]
  columns: [zz_svc_sow.tot_amt, zz_svc_sow.cust_nbr, customers.name]
  tags: [services, dirty_naming]
  archetype: services
  gold_sql: |
    SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count
    FROM {schema}.zz_svc_sow sow
    JOIN {schema}.customers c ON c.customer_id = sow.cust_nbr
    GROUP BY c.name
    ORDER BY total_value DESC
    LIMIT 10;

- id: dirty_rtl_pos_sales
  difficulty: challenging
  question: "Total POS sales by payment method for retail division {schema}."
  evidence: "Table is zz_pos_trnx with abbreviated columns: tot_amt, pay_mthd_cd, trnx_dt."
  tables: [zz_pos_trnx]
  columns: [zz_pos_trnx.pay_mthd_cd, zz_pos_trnx.tot_amt]
  tags: [retail, dirty_naming]
  archetype: retail
  gold_sql: |
    SELECT pay_mthd_cd, COUNT(*) AS txn_count,
           SUM(tot_amt) AS total_sales
    FROM {schema}.zz_pos_trnx
    GROUP BY pay_mthd_cd
    ORDER BY total_sales DESC;
