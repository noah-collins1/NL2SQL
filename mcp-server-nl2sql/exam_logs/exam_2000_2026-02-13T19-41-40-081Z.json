{
  "exam_file": "/home/noahc/nl2sql-project/exam/exam_full_300.csv",
  "timestamp": "2026-02-13T19:41:40.082Z",
  "model": "qwen2.5-coder:7b",
  "summary": {
    "total": 300,
    "success_rate": 76,
    "by_difficulty": {
      "simple": {
        "pass": 38,
        "fail": 2
      },
      "moderate": {
        "pass": 89,
        "fail": 31
      },
      "challenging": {
        "pass": 101,
        "fail": 39
      }
    },
    "failure_counts": {
      "success": 228,
      "column_miss": 35,
      "join_path_miss": 0,
      "value_miss": 0,
      "llm_reasoning": 30,
      "execution_error": 7
    },
    "by_tag": {
      "finance": {
        "pass": 38,
        "fail": 16
      },
      "ap": {
        "pass": 2,
        "fail": 0
      },
      "services": {
        "pass": 24,
        "fail": 4
      },
      "dirty_naming": {
        "pass": 22,
        "fail": 5
      },
      "ar": {
        "pass": 6,
        "fail": 5
      },
      "inventory": {
        "pass": 21,
        "fail": 2
      },
      "retail": {
        "pass": 29,
        "fail": 0
      },
      "lookup": {
        "pass": 13,
        "fail": 18
      },
      "procurement": {
        "pass": 25,
        "fail": 5
      },
      "sales": {
        "pass": 19,
        "fail": 18
      },
      "geography": {
        "pass": 0,
        "fail": 6
      },
      "multi_join": {
        "pass": 6,
        "fail": 6
      },
      "hr": {
        "pass": 32,
        "fail": 5
      },
      "time": {
        "pass": 5,
        "fail": 1
      },
      "temporal": {
        "pass": 13,
        "fail": 2
      },
      "support": {
        "pass": 10,
        "fail": 0
      },
      "kpi": {
        "pass": 8,
        "fail": 8
      },
      "projects": {
        "pass": 16,
        "fail": 9
      },
      "corporate": {
        "pass": 7,
        "fail": 6
      },
      "manufacturing": {
        "pass": 4,
        "fail": 16
      },
      "payroll": {
        "pass": 2,
        "fail": 0
      },
      "jargon": {
        "pass": 4,
        "fail": 3
      },
      "rate": {
        "pass": 2,
        "fail": 0
      },
      "assets": {
        "pass": 11,
        "fail": 0
      },
      "training": {
        "pass": 3,
        "fail": 0
      },
      "qc": {
        "pass": 4,
        "fail": 0
      },
      "window": {
        "pass": 1,
        "fail": 0
      },
      "aging": {
        "pass": 2,
        "fail": 2
      },
      "benefits": {
        "pass": 3,
        "fail": 0
      },
      "workflow": {
        "pass": 0,
        "fail": 2
      },
      "budget": {
        "pass": 3,
        "fail": 0
      },
      "top_n": {
        "pass": 0,
        "fail": 2
      },
      "aggregation": {
        "pass": 0,
        "fail": 2
      }
    }
  },
  "results": [
    {
      "qid": "Q0001",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total AP invoice amount by vendor for 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT v.vendor_id, v.name, SUM(fai.amount) AS total_ap_invoice_amount FROM finance_ap_invoices fai JOIN vendors v ON fai.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM fai.invoice_date) = 2024 GROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name, SUM(ai.amount) AS total_amount\n  FROM div_06.finance_ap_invoices ai\n  JOIN div_06.vendors v ON v.vendor_id = ai.vendor_id\n  WHERE EXTRACT(YEAR FROM ai.invoice_date) = 2024\n  GROUP BY v.name\n  ORDER BY total_amount DESC;",
      "success": true,
      "latency_ms": 10315,
      "tags": "finance,ap"
    },
    {
      "qid": "Q0002",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8351,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0003",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List open AR invoices over 5000 in 2023.",
      "target_schema": "div_06",
      "sql_generated": "SELECT ar_invoice_id, invoice_number, customer_id, invoice_date, due_date, amount, status FROM finance_ar_invoices WHERE status = 'Open' AND amount > 5000 AND EXTRACT(YEAR FROM invoice_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT ar_invoice_id, invoice_number, amount, status\n  FROM div_06.finance_ar_invoices\n  WHERE status = 'open'\n    AND amount > 5000\n    AND EXTRACT(YEAR FROM invoice_date) = 2023;",
      "success": true,
      "latency_ms": 6383,
      "tags": "finance,ar"
    },
    {
      "qid": "Q0004",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2021.",
      "target_schema": "div_08",
      "sql_generated": "SELECT pc.name AS product_category, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS turns FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN inventory_transactions it ON p.product_id = it.product_id WHERE date_trunc('year', it.transaction_date) = '2021-01-01' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_08.inventory_transactions it\n  JOIN div_08.products p ON p.product_id = it.product_id\n  JOIN div_08.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2021\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 13152,
      "tags": "inventory"
    },
    {
      "qid": "Q0005",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_15.",
      "target_schema": "div_15",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_15.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6785,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0006",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Vendors with payment terms of 15 days or more.",
      "target_schema": "div_10",
      "sql_generated": "SELECT vendor_id, name, payment_terms FROM vendors WHERE payment_terms >= 15 LIMIT 1000;",
      "gold_sql": "  SELECT vendor_id, name, payment_terms\n  FROM div_10.vendors\n  WHERE payment_terms >= 15;",
      "success": true,
      "latency_ms": 4028,
      "tags": "procurement"
    },
    {
      "qid": "Q0007",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2023.",
      "target_schema": "div_13",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.manager_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2023\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_13.sales_orders so\n  JOIN div_13.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_13.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_13.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_13.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2023\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21845,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0008",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Bank transaction totals by type for 2023.",
      "target_schema": "div_16",
      "sql_generated": "SELECT transaction_type, SUM(amount) AS total_amount FROM bank_transactions WHERE EXTRACT(YEAR FROM transaction_date) = 2023 GROUP BY transaction_type LIMIT 1000;",
      "gold_sql": "  SELECT transaction_type, SUM(amount) AS total_amount\n  FROM div_16.bank_transactions\n  WHERE EXTRACT(YEAR FROM transaction_date) = 2023\n  GROUP BY transaction_type;",
      "success": true,
      "latency_ms": 5939,
      "tags": "finance"
    },
    {
      "qid": "Q0009",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Number of journal entries by month in 2023.",
      "target_schema": "div_08",
      "sql_generated": "SELECT date_trunc('month', entry_date) AS month, COUNT(*) AS num_entries FROM journal_entries WHERE EXTRACT(YEAR FROM entry_date) = 2023 GROUP BY month ORDER BY month LIMIT 1000;",
      "gold_sql": "  SELECT DATE_TRUNC('month', entry_date) AS month, COUNT(*) AS entry_count\n  FROM div_08.journal_entries\n  WHERE EXTRACT(YEAR FROM entry_date) = 2023\n  GROUP BY month\n  ORDER BY month;",
      "success": true,
      "latency_ms": 5924,
      "tags": "finance"
    },
    {
      "qid": "Q0010",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_10.svc_statements_of_work sow\n  JOIN div_10.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": true,
      "latency_ms": 11827,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0011",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Procure-to-pay cycle: PO to receipt to invoice for each vendor in 2023.",
      "target_schema": "div_12",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, p.po_number, gr.receipt_number, vi.invoice_number, p.order_date, gr.receipt_date, vi.invoice_date \nFROM purchase_orders p \nJOIN goods_receipts gr ON p.po_id = gr.po_id \nJOIN vendor_invoices vi ON gr.receipt_id = vi.receipt_id \nJOIN vendors v ON vi.vendor_id = v.vendor_id \nWHERE EXTRACT(YEAR FROM p.order_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT v.name AS vendor,\n         po.po_id,\n         po.order_date,\n         gr.receipt_id,\n         gr.receipt_date,\n         vi.invoice_id,\n         vi.invoice_date,\n         vi.total AS invoice_total\n  FROM div_12.purchase_orders po\n  JOIN div_12.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_12.vendor_invoices vi ON vi.po_id = po.po_id\n  JOIN div_12.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2023\n  ORDER BY po.order_date\n  LIMIT 50;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column vi.receipt_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 20986,
      "tags": "procurement,multi_join"
    },
    {
      "qid": "Q0012",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Employees with more than 10 time clock entries in a week during 2023.",
      "target_schema": "div_18",
      "sql_generated": "SELECT e.employee_id, COUNT(tce.entry_id) AS entry_count FROM employees e JOIN hr_time_clock_entries tce ON e.employee_id = tce.employee_id WHERE tce.work_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY e.employee_id HAVING COUNT(tce.entry_id) > 10 LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, e.first_name, e.last_name, DATE_TRUNC('week', t.work_date) AS week_start, COUNT(*) AS entries\n  FROM div_18.hr_time_clock_entries t\n  JOIN div_18.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.work_date) = 2023\n  GROUP BY e.employee_id, e.first_name, e.last_name, week_start\n  HAVING COUNT(*) > 10;",
      "success": true,
      "latency_ms": 10053,
      "tags": "hr,time"
    },
    {
      "qid": "Q0013",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee tenure distribution (0-1yr, 1-3yr, 3-5yr, 5+yr) as of 2023.",
      "target_schema": "div_03",
      "sql_generated": "SELECT CASE WHEN EXTRACT(YEAR FROM AGE('2023-12-31', hire_date)) BETWEEN 0 AND 1 THEN '0-1yr' WHEN EXTRACT(YEAR FROM AGE('2023-12-31', hire_date)) BETWEEN 1 AND 3 THEN '1-3yr' WHEN EXTRACT(YEAR FROM AGE('2023-12-31', hire_date)) BETWEEN 3 AND 5 THEN '3-5yr' ELSE '5+yr' END AS tenure_bucket, COUNT(*) AS employee_count FROM employees WHERE termination_date IS NULL OR termination_date > '2023-12-31' GROUP BY tenure_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2023-12-31', hire_date)) < 1 THEN '0-1 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2023-12-31', hire_date)) < 3 THEN '1-3 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2023-12-31', hire_date)) < 5 THEN '3-5 yr'\n      ELSE '5+ yr'\n    END AS tenure_bucket,\n    COUNT(*) AS employee_count\n  FROM div_03.employees\n  WHERE hire_date <= DATE '2023-12-31'\n    AND (termination_date IS NULL OR termination_date > DATE '2023-12-31')\n  GROUP BY tenure_bucket\n  ORDER BY tenure_bucket;",
      "success": true,
      "latency_ms": 18475,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0014",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_14",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_14.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 4591,
      "tags": "support"
    },
    {
      "qid": "Q0015",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Order-to-cash cycle: customer, order, lines, AR invoice, payment for 2022.",
      "target_schema": "div_16",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, o.order_number, ol.line_id, ol.quantity, ol.unit_price, fai.invoice_number, fai.invoice_date, fap.payment_date, fap.amount AS payment_amount FROM customers c JOIN sales_orders o ON c.customer_id = o.customer_id JOIN order_lines ol ON o.order_id = ol.order_id JOIN finance_ar_invoices fai ON ol.line_id = fai.ar_invoice_id JOIN finance_ar_payments fap ON fai.ar_invoice_id = fap.ar_invoice_id WHERE EXTRACT(YEAR FROM fai.invoice_date) = 2022 LIMIT 1000;",
      "gold_sql": "  SELECT c.name AS customer,\n         so.order_id,\n         SUM(ol.quantity * ol.unit_price) AS order_total,\n         ar.invoice_number,\n         ar.amount AS invoice_amount,\n         p.payment_date,\n         p.amount AS payment_amount\n  FROM div_16.customers c\n  JOIN div_16.sales_orders so ON so.customer_id = c.customer_id\n  JOIN div_16.order_lines ol ON ol.order_id = so.order_id\n  JOIN div_16.finance_ar_invoices ar ON ar.customer_id = c.customer_id\n  LEFT JOIN div_16.finance_ar_payments p ON p.ar_invoice_id = ar.ar_invoice_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY c.name, so.order_id, ar.invoice_number, ar.amount, p.payment_date, p.amount\n  LIMIT 50;",
      "success": true,
      "latency_ms": 21355,
      "tags": "sales,finance,multi_join"
    },
    {
      "qid": "Q0016",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Days Sales Outstanding (DSO) by customer for 2023.",
      "target_schema": "div_10",
      "sql_generated": "",
      "gold_sql": "  SELECT c.name,\n         ROUND(AVG(p.payment_date - i.invoice_date), 1) AS avg_dso\n  FROM div_10.finance_ar_invoices i\n  JOIN div_10.finance_ar_payments p ON p.ar_invoice_id = i.ar_invoice_id\n  JOIN div_10.customers c ON c.customer_id = i.customer_id\n  WHERE EXTRACT(YEAR FROM i.invoice_date) = 2023\n  GROUP BY c.name\n  ORDER BY avg_dso DESC;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 12354,
      "tags": "finance,ar,kpi"
    },
    {
      "qid": "Q0017",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Approval rate of purchase orders in 2022.",
      "target_schema": "div_10",
      "sql_generated": "SELECT approval_date, SUM(CASE WHEN status = 'Approved' THEN 1 ELSE 0 END) AS approved_count, SUM(CASE WHEN status = 'Rejected' THEN 1 ELSE 0 END) AS rejected_count FROM procurement_po_approvals WHERE EXTRACT(YEAR FROM approval_date) = 2022 GROUP BY approval_date LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) / COUNT(*), 2) AS approval_pct\n  FROM div_10.procurement_po_approvals\n  WHERE EXTRACT(YEAR FROM approval_date) = 2022;",
      "success": true,
      "latency_ms": 15213,
      "tags": "procurement"
    },
    {
      "qid": "Q0018",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Gross margin (revenue - COGS estimate) by product for 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT p.product_id, p.name, SUM(ol.line_total) AS revenue, SUM(ol.quantity * p.list_price * 0.6) AS cogs_estimate, (SUM(ol.line_total) - SUM(ol.quantity * p.list_price * 0.6)) AS gross_margin \nFROM order_lines ol \nJOIN products p ON ol.product_id = p.product_id \nWHERE EXTRACT(YEAR FROM ol.order_date) = 2024 \nGROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         SUM(ol.quantity * ol.unit_price) AS revenue,\n         SUM(ol.quantity * ol.unit_price * 0.6) AS estimated_cogs,\n         ROUND(SUM(ol.quantity * ol.unit_price * 0.4), 2) AS gross_margin\n  FROM div_06.order_lines ol\n  JOIN div_06.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_06.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY p.name\n  ORDER BY gross_margin DESC\n  LIMIT 20;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 22533,
      "tags": "sales,finance,kpi"
    },
    {
      "qid": "Q0019",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top expense categories for 2024.",
      "target_schema": "div_09",
      "sql_generated": "SELECT category, SUM(amount) AS total_amount FROM project_expenses WHERE EXTRACT(YEAR FROM expense_date) = 2024 GROUP BY category ORDER BY total_amount DESC LIMIT 1000;",
      "gold_sql": "  SELECT category, SUM(amount) AS total\n  FROM div_09.project_expenses\n  WHERE EXTRACT(YEAR FROM expense_date) = 2024\n  GROUP BY category\n  ORDER BY total DESC;",
      "success": true,
      "latency_ms": 6398,
      "tags": "projects"
    },
    {
      "qid": "Q0020",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Net intercompany balance between divisions for corporate division div_18.",
      "target_schema": "div_18",
      "sql_generated": "SELECT from_division, to_division, SUM(CASE WHEN from_division = 'div_18' THEN amount ELSE 0 END) AS sent, SUM(CASE WHEN to_division = 'div_18' THEN amount ELSE 0 END) AS received, (SUM(CASE WHEN from_division = 'div_18' THEN amount ELSE 0 END) - SUM(CASE WHEN to_division = 'div_18' THEN amount ELSE 0 END)) AS net_balance FROM corp_intercompany_txns WHERE from_division IN ('div_18', 'other_div') AND to_division IN ('div_18', 'other_div') GROUP BY from_division, to_division LIMIT 1000;",
      "gold_sql": "  SELECT from_division, to_division,\n         SUM(amount) AS total_transferred,\n         COUNT(*) AS txn_count\n  FROM div_18.corp_intercompany_txns\n  WHERE status_code = 'AP'\n  GROUP BY from_division, to_division\n  ORDER BY total_transferred DESC;",
      "success": true,
      "latency_ms": 18135,
      "tags": "corporate"
    },
    {
      "qid": "Q0021",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total SOW contract value by customer for services division div_08.",
      "target_schema": "div_08",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, SUM(sow.total_amount) AS total_contract_value \nFROM svc_statements_of_work sow \nJOIN customers c ON sow.customer_id = c.customer_id \nGROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.total_amount) AS total_contract_value, COUNT(*) AS sow_count\n  FROM div_08.svc_statements_of_work sow\n  JOIN div_08.customers c ON c.customer_id = sow.customer_id\n  GROUP BY c.name\n  ORDER BY total_contract_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 11978,
      "tags": "services"
    },
    {
      "qid": "Q0022",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_03.",
      "target_schema": "div_03",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_03.mfg_work_orders wo\n  JOIN div_03.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 12480,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0023",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2023.",
      "target_schema": "div_05",
      "sql_generated": "SELECT pc.name AS category_name, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS inventory_turns FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN inventory_transactions it ON p.product_id = it.product_id WHERE it.transaction_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_05.inventory_transactions it\n  JOIN div_05.products p ON p.product_id = it.product_id\n  JOIN div_05.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2023\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 13140,
      "tags": "inventory"
    },
    {
      "qid": "Q0024",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Headcount by department for 2023.",
      "target_schema": "div_02",
      "sql_generated": "SELECT d.name AS department_name, COUNT(e.employee_id) AS headcount FROM departments d JOIN employees e ON d.department_id = e.department_id WHERE EXTRACT(YEAR FROM e.hire_date) = 2023 GROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name, COUNT(*) AS headcount\n  FROM div_02.employees e\n  JOIN div_02.departments d ON d.department_id = e.department_id\n  WHERE EXTRACT(YEAR FROM e.hire_date) <= 2023\n  GROUP BY d.name\n  ORDER BY headcount DESC;",
      "success": true,
      "latency_ms": 8658,
      "tags": "hr"
    },
    {
      "qid": "Q0025",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Vendor invoices past due as of today.",
      "target_schema": "div_20",
      "sql_generated": "SELECT invoice_id, invoice_number, vendor_id, due_date, status FROM vendor_invoices WHERE due_date < CURRENT_DATE AND status = 'Unpaid' LIMIT 1000;",
      "gold_sql": "  SELECT invoice_id, vendor_id, due_date, total, status\n  FROM div_20.vendor_invoices\n  WHERE due_date < CURRENT_DATE AND status <> 'paid';",
      "success": true,
      "latency_ms": 3297,
      "tags": "procurement"
    },
    {
      "qid": "Q0026",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top expense categories for 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT category, SUM(amount) AS total_amount FROM project_expenses WHERE EXTRACT(YEAR FROM expense_date) = 2021 GROUP BY category ORDER BY total_amount DESC LIMIT 1000;",
      "gold_sql": "  SELECT category, SUM(amount) AS total\n  FROM div_05.project_expenses\n  WHERE EXTRACT(YEAR FROM expense_date) = 2021\n  GROUP BY category\n  ORDER BY total DESC;",
      "success": true,
      "latency_ms": 6284,
      "tags": "projects"
    },
    {
      "qid": "Q0027",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total payroll net pay by pay period for 2023.",
      "target_schema": "div_11",
      "sql_generated": "SELECT prh.pay_period_start, SUM(prl.net_pay) AS total_net_pay FROM payroll_run_hdr prh JOIN payroll_run_line prl ON prh.run_id = prl.run_id WHERE EXTRACT(YEAR FROM prh.pay_period_start) = 2023 GROUP BY prh.pay_period_start LIMIT 1000;",
      "gold_sql": "  SELECT h.pay_period_start, h.pay_period_end, SUM(l.net_pay) AS total_net_pay\n  FROM div_11.payroll_run_hdr h\n  JOIN div_11.payroll_run_line l ON l.run_id = h.run_id\n  WHERE EXTRACT(YEAR FROM h.pay_period_start) = 2023\n  GROUP BY h.pay_period_start, h.pay_period_end\n  ORDER BY h.pay_period_start;",
      "success": true,
      "latency_ms": 10831,
      "tags": "hr,payroll"
    },
    {
      "qid": "Q0028",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2021.",
      "target_schema": "div_03",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2021-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_03.journal_lines jl\n  JOIN div_03.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_03.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2021\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 10056,
      "tags": "finance"
    },
    {
      "qid": "Q0029",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List open sales opportunities with probability over 0.6.",
      "target_schema": "div_07",
      "sql_generated": "SELECT opportunity_id, name, customer_id, owner_id, stage_id, amount, probability, expected_close_date, actual_close_date, source, created_at FROM sales_opportunities WHERE probability > 0.6 AND is_closed = false LIMIT 1000;",
      "gold_sql": "  SELECT opportunity_id, name, amount, probability\n  FROM div_07.sales_opportunities\n  WHERE probability > 0.6;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"is_closed\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 10098,
      "tags": "sales"
    },
    {
      "qid": "Q0030",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_11.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6596,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0031",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Departments where actual expenses exceed budget in 2024.",
      "target_schema": "div_02",
      "sql_generated": "SELECT \n    b.department_id,\n    d.name AS department_name,\n    SUM(pe.amount) AS actual_expenses,\n    SUM(pb.planned_amount) AS budgeted_amount\nFROM \n    project_budgets pb\nJOIN \n    projects p ON pb.project_id = p.project_id\nJOIN \n    project_expenses pe ON p.project_id = pe.project_id\nJOIN \n    budgets b ON pb.budget_id = b.budget_id\nJOIN \n    departments d ON b.department_id = d.department_id\nWHERE \n    EXTRACT(YEAR FROM pe.expense_date) = 2024\nGROUP BY \n    b.department_id, d.name\nHAVING \n    SUM(pe.amount) > SUM(pb.planned_amount);",
      "gold_sql": "  SELECT d.name, b.total_amount, COALESCE(SUM(pe.amount),0) AS actual_spend\n  FROM div_02.budgets b\n  JOIN div_02.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_02.project_expenses pe ON pe.project_id IS NOT NULL\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2024\n  GROUP BY d.name, b.total_amount\n  HAVING COALESCE(SUM(pe.amount),0) > b.total_amount;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 22265,
      "tags": "finance,projects"
    },
    {
      "qid": "Q0032",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Working capital ratio: current assets (AR) vs current liabilities (AP) for 2022.",
      "target_schema": "div_11",
      "sql_generated": "SELECT SUM(ar.amount) AS ar_open_amounts, SUM(ap.amount) AS ap_open_amounts, (SUM(ar.amount) * 100.0 / NULLIF(SUM(ap.amount), 0)) AS working_capital_ratio FROM finance_ar_invoices ar JOIN finance_ar_payments ap ON ar.ar_invoice_id = ap.ar_invoice_id WHERE EXTRACT(YEAR FROM ar.invoice_date) = 2022 LIMIT 1000;",
      "gold_sql": "  WITH ar AS (\n    SELECT SUM(amount) AS total_ar\n    FROM div_11.finance_ar_invoices\n    WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = 2022\n  ),\n  ap AS (\n    SELECT SUM(amount) AS total_ap\n    FROM div_11.finance_ap_invoices\n    WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = 2022\n  )\n  SELECT ar.total_ar, ap.total_ap,\n         ROUND(ar.total_ar / NULLIF(ap.total_ap, 0), 2) AS working_capital_ratio\n  FROM ar, ap;",
      "success": true,
      "latency_ms": 17903,
      "tags": "finance,jargon"
    },
    {
      "qid": "Q0033",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee turnover rate for 2022.",
      "target_schema": "div_03",
      "sql_generated": "SELECT AVG(CASE WHEN termination_date BETWEEN '2022-01-01' AND '2022-12-31' THEN 1 ELSE 0 END) AS turnover_rate FROM employees LIMIT 1000;",
      "gold_sql": "  WITH terminations AS (\n    SELECT COUNT(*) AS term_count\n    FROM div_03.employees\n    WHERE EXTRACT(YEAR FROM termination_date) = 2022\n  ),\n  headcount AS (\n    SELECT COUNT(*) AS headcount\n    FROM div_03.employees\n    WHERE hire_date <= DATE '2022-12-31'\n      AND (termination_date IS NULL OR termination_date > DATE '2022-01-01')\n  )\n  SELECT ROUND(100.0 * t.term_count / NULLIF(h.headcount,0), 2) AS turnover_pct\n  FROM terminations t, headcount h;",
      "success": true,
      "latency_ms": 8467,
      "tags": "hr"
    },
    {
      "qid": "Q0034",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "What percentage of AR invoices were late in 2024?",
      "target_schema": "div_10",
      "sql_generated": "SELECT SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) AS late_percentage FROM vendor_invoices WHERE invoice_date < CURRENT_DATE AND EXTRACT(YEAR FROM invoice_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) / COUNT(*), 2) AS late_pct\n  FROM div_10.finance_ar_invoices\n  WHERE EXTRACT(YEAR FROM invoice_date) = 2024;",
      "success": true,
      "latency_ms": 10433,
      "tags": "finance,ar,rate"
    },
    {
      "qid": "Q0035",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Timesheets awaiting approval in 2024.",
      "target_schema": "div_05",
      "sql_generated": "SELECT employee_id, week_start_date, total_hours FROM timesheets WHERE status = 'submitted' AND EXTRACT(YEAR FROM submitted_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT timesheet_id, employee_id, week_start_date, status\n  FROM div_05.timesheets\n  WHERE status = 'submitted'\n    AND EXTRACT(YEAR FROM week_start_date) = 2024;",
      "success": true,
      "latency_ms": 5897,
      "tags": "projects"
    },
    {
      "qid": "Q0036",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_07.",
      "target_schema": "div_07",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_07.zz_svc_sow sow\n  JOIN div_07.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 7891,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0037",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2024.",
      "target_schema": "div_04",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.region_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2024\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_04.sales_orders so\n  JOIN div_04.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_04.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_04.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_04.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21281,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0038",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top expense categories for 2023.",
      "target_schema": "div_12",
      "sql_generated": "SELECT category, SUM(amount) AS total_amount FROM project_expenses WHERE EXTRACT(YEAR FROM expense_date) = 2023 GROUP BY category ORDER BY total_amount DESC LIMIT 1000;",
      "gold_sql": "  SELECT category, SUM(amount) AS total\n  FROM div_12.project_expenses\n  WHERE EXTRACT(YEAR FROM expense_date) = 2023\n  GROUP BY category\n  ORDER BY total DESC;",
      "success": true,
      "latency_ms": 6274,
      "tags": "projects"
    },
    {
      "qid": "Q0039",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Days Sales Outstanding (DSO) by customer for 2021.",
      "target_schema": "div_17",
      "sql_generated": "",
      "gold_sql": "  SELECT c.name,\n         ROUND(AVG(p.payment_date - i.invoice_date), 1) AS avg_dso\n  FROM div_17.finance_ar_invoices i\n  JOIN div_17.finance_ar_payments p ON p.ar_invoice_id = i.ar_invoice_id\n  JOIN div_17.customers c ON c.customer_id = i.customer_id\n  WHERE EXTRACT(YEAR FROM i.invoice_date) = 2021\n  GROUP BY c.name\n  ORDER BY avg_dso DESC;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 11837,
      "tags": "finance,ar,kpi"
    },
    {
      "qid": "Q0040",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8349,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0041",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total depreciation by period for 2023.",
      "target_schema": "div_04",
      "sql_generated": "SELECT period_id, SUM(amount) AS total_depreciation FROM depreciation_entries WHERE period_id IN (SELECT period_id FROM fiscal_periods WHERE fiscal_year_id = 2023) GROUP BY period_id LIMIT 1000;",
      "gold_sql": "  SELECT fp.start_date, SUM(de.amount) AS total_depr\n  FROM div_04.depreciation_entries de\n  JOIN div_04.fiscal_periods fp ON fp.period_id = de.period_id\n  WHERE EXTRACT(YEAR FROM fp.start_date) = 2023\n  GROUP BY fp.start_date\n  ORDER BY fp.start_date;",
      "success": true,
      "latency_ms": 9151,
      "tags": "assets,finance"
    },
    {
      "qid": "Q0042",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Compare effective vs statutory tax rate by jurisdiction for corporate division div_19.",
      "target_schema": "div_19",
      "sql_generated": "SELECT t.jurisdiction, t.effective_rate, t.statutory_rate, (t.effective_rate - t.statutory_rate) * 100.0 / NULLIF(t.statutory_rate, 0) AS rate_difference_pct FROM corp_tax_provisions t WHERE t.division = 'div_19' LIMIT 1000;",
      "gold_sql": "  SELECT jurisdiction, tax_type,\n         ROUND(AVG(effective_rate), 4) AS avg_effective_rate,\n         ROUND(AVG(statutory_rate), 4) AS avg_statutory_rate,\n         ROUND(AVG(statutory_rate - effective_rate), 4) AS avg_rate_gap,\n         SUM(current_provision + deferred_provision) AS total_provision\n  FROM div_19.corp_tax_provisions\n  GROUP BY jurisdiction, tax_type\n  ORDER BY total_provision DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column t.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 11562,
      "tags": "corporate"
    },
    {
      "qid": "Q0043",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Project margin = (budget - actual expenses) for active projects in 2024.",
      "target_schema": "div_18",
      "sql_generated": "SELECT p.project_id, p.name AS project_name, pb.planned_amount AS budget, SUM(pe.amount) AS actual_expenses, (pb.planned_amount - SUM(pe.amount)) AS margin FROM projects p JOIN project_budgets pb ON p.project_id = pb.project_id LEFT JOIN project_expenses pe ON p.project_id = pe.project_id AND pe.status = 'Approved' WHERE p.status = 'Active' AND EXTRACT(YEAR FROM p.start_date) = 2024 GROUP BY p.project_id, p.name, pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.project_id, p.name,\n         pb.planned_amount - COALESCE(SUM(pe.amount),0) AS margin\n  FROM div_18.projects p\n  JOIN div_18.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_18.project_expenses pe ON pe.project_id = p.project_id\n  WHERE p.status = 'active'\n    AND EXTRACT(YEAR FROM p.start_date) = 2024\n  GROUP BY p.project_id, p.name, pb.planned_amount\n  ORDER BY margin DESC;",
      "success": true,
      "latency_ms": 18130,
      "tags": "projects"
    },
    {
      "qid": "Q0044",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_15.",
      "target_schema": "div_15",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS total_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_15.rtl_pos_line_items li\n  JOIN div_15.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 7760,
      "tags": "retail"
    },
    {
      "qid": "Q0045",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average resource allocation percent by role for active SOWs in services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT r.role_name, AVG(r.allocation_percent) AS avg_allocation\nFROM svc_resource_plan r\nJOIN svc_statements_of_work s ON r.sow_id = s.sow_id\nWHERE s.status_code = 'AC'\nGROUP BY r.role_name LIMIT 1000;",
      "gold_sql": "  SELECT rp.role_name,\n         ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,\n         COUNT(*) AS assignments\n  FROM div_06.svc_resource_plan rp\n  JOIN div_06.svc_statements_of_work sow ON sow.sow_id = rp.sow_id\n  WHERE sow.status_code = 'AC'\n  GROUP BY rp.role_name\n  ORDER BY avg_allocation DESC;",
      "success": true,
      "latency_ms": 9277,
      "tags": "services,kpi"
    },
    {
      "qid": "Q0046",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total payroll net pay by pay period for 2023.",
      "target_schema": "div_15",
      "sql_generated": "SELECT prh.pay_period_start, SUM(prl.net_pay) AS total_net_pay FROM payroll_run_hdr prh JOIN payroll_run_line prl ON prh.run_id = prl.run_id WHERE EXTRACT(YEAR FROM prh.pay_period_start) = 2023 GROUP BY prh.pay_period_start LIMIT 1000;",
      "gold_sql": "  SELECT h.pay_period_start, h.pay_period_end, SUM(l.net_pay) AS total_net_pay\n  FROM div_15.payroll_run_hdr h\n  JOIN div_15.payroll_run_line l ON l.run_id = h.run_id\n  WHERE EXTRACT(YEAR FROM h.pay_period_start) = 2023\n  GROUP BY h.pay_period_start, h.pay_period_end\n  ORDER BY h.pay_period_start;",
      "success": true,
      "latency_ms": 10550,
      "tags": "hr,payroll"
    },
    {
      "qid": "Q0047",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total SOW contract value by customer for services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.total_amount) AS total_sow_value \nFROM svc_statements_of_work s \nJOIN customers c ON s.customer_id = c.customer_id \nGROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.total_amount) AS total_contract_value, COUNT(*) AS sow_count\n  FROM div_06.svc_statements_of_work sow\n  JOIN div_06.customers c ON c.customer_id = sow.customer_id\n  GROUP BY c.name\n  ORDER BY total_contract_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8007,
      "tags": "services"
    },
    {
      "qid": "Q0048",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average resource allocation percent by role for active SOWs in services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT r.role_name, AVG(r.allocation_percent) AS avg_allocation\nFROM svc_resource_plan r\nJOIN svc_statements_of_work s ON r.sow_id = s.sow_id\nWHERE s.status_code = 'AC'\nGROUP BY r.role_name LIMIT 1000;",
      "gold_sql": "  SELECT rp.role_name,\n         ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,\n         COUNT(*) AS assignments\n  FROM div_06.svc_resource_plan rp\n  JOIN div_06.svc_statements_of_work sow ON sow.sow_id = rp.sow_id\n  WHERE sow.status_code = 'AC'\n  GROUP BY rp.role_name\n  ORDER BY avg_allocation DESC;",
      "success": true,
      "latency_ms": 9256,
      "tags": "services,kpi"
    },
    {
      "qid": "Q0049",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_11.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6472,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0050",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "High and critical priority work orders using lookup codes in div_03.",
      "target_schema": "div_03",
      "sql_generated": "SELECT w.work_order_number, w.quantity_ordered, w.quantity_completed, w.start_date, w.end_date, l.meaning AS priority_code_meaning FROM mfg_work_orders w JOIN lookup_codes l ON w.priority_code = l.code AND l.domain = 'PRIORITY' WHERE l.meaning IN ('High', 'Critical') LIMIT 1000;",
      "gold_sql": "  SELECT wo.work_order_id, wo.work_order_number, lc.meaning AS priority\n  FROM div_03.mfg_work_orders wo\n  JOIN div_03.lookup_codes lc ON lc.code = wo.priority_code AND lc.domain = 'PRIORITY'\n  WHERE lc.meaning IN ('High', 'Critical');",
      "success": true,
      "latency_ms": 11419,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0051",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Training completion rate by course for 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT tc.course_id, tc.name, COUNT(et.employee_id) AS completed_count, COUNT(*) AS total_enrollments, (COUNT(et.employee_id) * 100.0 / NULLIF(COUNT(*), 0)) AS completion_rate FROM training_courses tc LEFT JOIN employee_training et ON tc.course_id = et.course_id AND et.completion_date IS NOT NULL WHERE EXTRACT(YEAR FROM et.completion_date) = 2024 GROUP BY tc.course_id, tc.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, COUNT(*) AS completions\n  FROM div_06.employee_training et\n  JOIN div_06.training_courses c ON c.course_id = et.course_id\n  WHERE EXTRACT(YEAR FROM et.completion_date) = 2024\n  GROUP BY c.name\n  ORDER BY completions DESC;",
      "success": true,
      "latency_ms": 15117,
      "tags": "hr,training"
    },
    {
      "qid": "Q0052",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_13.",
      "target_schema": "div_13",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE status_code = 'Active' AND tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_13.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6639,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0053",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Projects where actual expenses exceed project budget.",
      "target_schema": "div_04",
      "sql_generated": "SELECT p.project_id, p.name, pb.budget_id, pb.planned_amount, SUM(pe.amount) AS total_expenses FROM projects p JOIN project_budgets pb ON p.project_id = pb.project_id LEFT JOIN project_expenses pe ON p.project_id = pe.project_id GROUP BY p.project_id, p.name, pb.budget_id, pb.planned_amount HAVING SUM(pe.amount) > pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.project_id, p.name\n  FROM div_04.projects p\n  JOIN div_04.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_04.project_expenses pe ON pe.project_id = p.project_id\n  GROUP BY p.project_id, p.name, pb.planned_amount\n  HAVING COALESCE(SUM(pe.amount),0) > pb.planned_amount;",
      "success": true,
      "latency_ms": 11814,
      "tags": "projects"
    },
    {
      "qid": "Q0054",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Period-over-period headcount change by month for 2022.",
      "target_schema": "div_08",
      "sql_generated": "SELECT date_trunc('month', e.hire_date) AS month, COUNT(e.employee_id) AS headcount FROM employees e WHERE e.termination_date IS NULL AND e.hire_date <= '2022-12-31' GROUP BY month ORDER BY month LIMIT 1000;",
      "gold_sql": "  WITH months AS (\n    SELECT generate_series(1, 12) AS month_num\n  ),\n  headcount AS (\n    SELECT m.month_num,\n           COUNT(*) AS hc\n    FROM months m\n    JOIN div_08.employees e ON e.hire_date <= DATE '2022-12-31'\n      AND (DATE '2022-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date\n      AND (e.termination_date IS NULL\n           OR e.termination_date > DATE '2022-01-01' + (m.month_num - 1) * INTERVAL '1 month')\n    GROUP BY m.month_num\n  )\n  SELECT month_num, hc,\n         hc - LAG(hc) OVER (ORDER BY month_num) AS change\n  FROM headcount\n  ORDER BY month_num;",
      "success": true,
      "latency_ms": 14426,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0055",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_12.",
      "target_schema": "div_12",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_12.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6691,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0056",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Order-to-cash cycle: customer, order, lines, AR invoice, payment for 2021.",
      "target_schema": "div_20",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, o.order_number, ol.line_id, ol.quantity, ol.unit_price, a.invoice_number, a.invoice_date, p.payment_id, p.payment_date, p.amount AS payment_amount FROM customers c JOIN sales_orders o ON c.customer_id = o.customer_id JOIN order_lines ol ON o.order_id = ol.order_id JOIN finance_ar_invoices a ON ol.line_id = a.ar_invoice_id JOIN finance_ar_payments p ON a.ar_invoice_id = p.ar_invoice_id WHERE EXTRACT(YEAR FROM a.invoice_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT c.name AS customer,\n         so.order_id,\n         SUM(ol.quantity * ol.unit_price) AS order_total,\n         ar.invoice_number,\n         ar.amount AS invoice_amount,\n         p.payment_date,\n         p.amount AS payment_amount\n  FROM div_20.customers c\n  JOIN div_20.sales_orders so ON so.customer_id = c.customer_id\n  JOIN div_20.order_lines ol ON ol.order_id = so.order_id\n  JOIN div_20.finance_ar_invoices ar ON ar.customer_id = c.customer_id\n  LEFT JOIN div_20.finance_ar_payments p ON p.ar_invoice_id = ar.ar_invoice_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY c.name, so.order_id, ar.invoice_number, ar.amount, p.payment_date, p.amount\n  LIMIT 50;",
      "success": true,
      "latency_ms": 18860,
      "tags": "sales,finance,multi_join"
    },
    {
      "qid": "Q0057",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Compare effective vs statutory tax rate by jurisdiction for corporate division div_16.",
      "target_schema": "div_16",
      "sql_generated": "SELECT t.jurisdiction, AVG(t.effective_rate) AS avg_effective_rate, AVG(t.statutory_rate) AS avg_statutory_rate \nFROM corp_tax_provisions t \nWHERE t.division = 'div_16' \nGROUP BY t.jurisdiction LIMIT 1000;",
      "gold_sql": "  SELECT jurisdiction, tax_type,\n         ROUND(AVG(effective_rate), 4) AS avg_effective_rate,\n         ROUND(AVG(statutory_rate), 4) AS avg_statutory_rate,\n         ROUND(AVG(statutory_rate - effective_rate), 4) AS avg_rate_gap,\n         SUM(current_provision + deferred_provision) AS total_provision\n  FROM div_16.corp_tax_provisions\n  GROUP BY jurisdiction, tax_type\n  ORDER BY total_provision DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column t.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 13146,
      "tags": "corporate"
    },
    {
      "qid": "Q0058",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total SOW contract value by customer for services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, SUM(sow.total_amount) AS total_contract_value \nFROM svc_statements_of_work sow \nJOIN customers c ON sow.customer_id = c.customer_id \nGROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.total_amount) AS total_contract_value, COUNT(*) AS sow_count\n  FROM div_10.svc_statements_of_work sow\n  JOIN div_10.customers c ON c.customer_id = sow.customer_id\n  GROUP BY c.name\n  ORDER BY total_contract_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8164,
      "tags": "services"
    },
    {
      "qid": "Q0059",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_number, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_number LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 7304,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0060",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inventory lots expiring within 60 days.",
      "target_schema": "div_11",
      "sql_generated": "SELECT lot_id, product_id, warehouse_id, lot_number, received_date, expiration_date, quantity FROM inventory_lots WHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' LIMIT 1000;",
      "gold_sql": "  SELECT lot_id, lot_number, expiration_date\n  FROM div_11.inventory_lots\n  WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';",
      "success": true,
      "latency_ms": 6726,
      "tags": "inventory"
    },
    {
      "qid": "Q0061",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Employees with more than 10 time clock entries in a week during 2024.",
      "target_schema": "div_14",
      "sql_generated": "SELECT e.employee_id, COUNT(tce.entry_id) AS entry_count FROM employees e JOIN hr_time_clock_entries tce ON e.employee_id = tce.employee_id WHERE tce.work_date BETWEEN '2024-01-01' AND '2024-12-31' GROUP BY e.employee_id HAVING COUNT(tce.entry_id) > 10 LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, e.first_name, e.last_name, DATE_TRUNC('week', t.work_date) AS week_start, COUNT(*) AS entries\n  FROM div_14.hr_time_clock_entries t\n  JOIN div_14.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.work_date) = 2024\n  GROUP BY e.employee_id, e.first_name, e.last_name, week_start\n  HAVING COUNT(*) > 10;",
      "success": true,
      "latency_ms": 10177,
      "tags": "hr,time"
    },
    {
      "qid": "Q0062",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_17",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_17.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 4539,
      "tags": "support"
    },
    {
      "qid": "Q0063",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Assets transferred between locations in 2022.",
      "target_schema": "div_10",
      "sql_generated": "SELECT at.transfer_id, fa.asset_tag, al1.name AS from_location, al2.name AS to_location, at.transfer_date, at.reason, at.transferred_by FROM asset_transfers at JOIN fixed_assets fa ON at.asset_id = fa.asset_id JOIN asset_locations al1 ON at.from_location_id = al1.location_id JOIN asset_locations al2 ON at.to_location_id = al2.location_id WHERE EXTRACT(YEAR FROM at.transfer_date) = 2022 LIMIT 1000;",
      "gold_sql": "  SELECT transfer_id, asset_id, from_location_id, to_location_id, transfer_date\n  FROM div_10.asset_transfers\n  WHERE EXTRACT(YEAR FROM transfer_date) = 2022;",
      "success": true,
      "latency_ms": 12747,
      "tags": "assets"
    },
    {
      "qid": "Q0064",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Customers with credit limit over 500.",
      "target_schema": "div_09",
      "sql_generated": "SELECT customer_id, name, credit_limit FROM customers WHERE credit_limit > 500;",
      "gold_sql": "  SELECT customer_id, name, credit_limit\n  FROM div_09.customers\n  WHERE credit_limit > 500;",
      "success": true,
      "latency_ms": 4023,
      "tags": "sales"
    },
    {
      "qid": "Q0065",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Quote-to-order conversion rate for 2024.",
      "target_schema": "div_05",
      "sql_generated": "SELECT q.customer_id, COUNT(o.order_id) AS orders_count, COUNT(q.quote_id) AS quotes_count, (COUNT(o.order_id) * 100.0 / NULLIF(COUNT(q.quote_id), 0)) AS conversion_rate FROM sales_quotes q LEFT JOIN sales_orders o ON q.customer_id = o.customer_id AND EXTRACT(YEAR FROM q.quote_date) = 2024 AND EXTRACT(YEAR FROM o.order_date) = 2024 GROUP BY q.customer_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * COUNT(DISTINCT so.order_id) / NULLIF(COUNT(DISTINCT sq.quote_id),0), 2) AS conversion_pct\n  FROM div_05.sales_quotes sq\n  LEFT JOIN div_05.sales_orders so ON so.customer_id = sq.customer_id\n  WHERE EXTRACT(YEAR FROM sq.quote_date) = 2024;",
      "success": true,
      "latency_ms": 13592,
      "tags": "sales"
    },
    {
      "qid": "Q0066",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top 5 vendors by total spend in 2021.",
      "target_schema": "div_01",
      "sql_generated": "SELECT v.vendor_number, v.name, SUM(po.total) AS total_spend FROM vendors v JOIN purchase_orders po ON v.vendor_id = po.vendor_id WHERE EXTRACT(YEAR FROM po.order_date) = 2021 GROUP BY v.vendor_number, v.name ORDER BY total_spend DESC LIMIT 5;",
      "gold_sql": "  SELECT v.name, SUM(po.total) AS total_spend\n  FROM div_01.purchase_orders po\n  JOIN div_01.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2021\n  GROUP BY v.name\n  ORDER BY total_spend DESC\n  LIMIT 5;",
      "success": true,
      "latency_ms": 10231,
      "tags": "procurement"
    },
    {
      "qid": "Q0067",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_03.",
      "target_schema": "div_03",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_03.mfg_work_orders wo\n  JOIN div_03.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 14296,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0068",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Period-over-period headcount change by month for 2023.",
      "target_schema": "div_02",
      "sql_generated": "SELECT \n    date_trunc('month', e.hire_date) AS month,\n    COUNT(e.employee_id) AS headcount\nFROM \n    employees e\nWHERE \n    e.termination_date IS NULL AND\n    e.hire_date <= '2023-12-31'\nGROUP BY \n    month\nORDER BY \n    month LIMIT 1000;",
      "gold_sql": "  WITH months AS (\n    SELECT generate_series(1, 12) AS month_num\n  ),\n  headcount AS (\n    SELECT m.month_num,\n           COUNT(*) AS hc\n    FROM months m\n    JOIN div_02.employees e ON e.hire_date <= DATE '2023-12-31'\n      AND (DATE '2023-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date\n      AND (e.termination_date IS NULL\n           OR e.termination_date > DATE '2023-01-01' + (m.month_num - 1) * INTERVAL '1 month')\n    GROUP BY m.month_num\n  )\n  SELECT month_num, hc,\n         hc - LAG(hc) OVER (ORDER BY month_num) AS change\n  FROM headcount\n  ORDER BY month_num;",
      "success": true,
      "latency_ms": 17214,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0069",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "QC failure rate for inventory lots in 2021.",
      "target_schema": "div_15",
      "sql_generated": "SELECT lot_id, COUNT(*) FILTER (WHERE result = 'fail') AS fail_count, COUNT(*) AS total_count, (COUNT(*) FILTER (WHERE result = 'fail') * 100.0 / NULLIF(COUNT(*), 0)) AS failure_rate FROM inventory_qc_inspections WHERE inspection_date BETWEEN '2021-01-01' AND '2021-12-31' GROUP BY lot_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN qi.result = 'fail' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_pct\n  FROM div_15.inventory_qc_inspections qi\n  WHERE EXTRACT(YEAR FROM qi.inspection_date) = 2021;",
      "success": true,
      "latency_ms": 16808,
      "tags": "inventory,qc"
    },
    {
      "qid": "Q0070",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Net intercompany balance between divisions for corporate division div_16.",
      "target_schema": "div_16",
      "sql_generated": "SELECT from_division, to_division, SUM(CASE WHEN from_division = 'div_16' THEN amount ELSE 0 END) AS sent, SUM(CASE WHEN to_division = 'div_16' THEN amount ELSE 0 END) AS received, (SUM(CASE WHEN from_division = 'div_16' THEN amount ELSE 0 END) - SUM(CASE WHEN to_division = 'div_16' THEN amount ELSE 0 END)) AS net_balance FROM corp_intercompany_txns GROUP BY from_division, to_division LIMIT 1000;",
      "gold_sql": "  SELECT from_division, to_division,\n         SUM(amount) AS total_transferred,\n         COUNT(*) AS txn_count\n  FROM div_16.corp_intercompany_txns\n  WHERE status_code = 'AP'\n  GROUP BY from_division, to_division\n  ORDER BY total_transferred DESC;",
      "success": true,
      "latency_ms": 17696,
      "tags": "corporate"
    },
    {
      "qid": "Q0071",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Days Sales Outstanding (DSO) by customer for 2024.",
      "target_schema": "div_14",
      "sql_generated": "",
      "gold_sql": "  SELECT c.name,\n         ROUND(AVG(p.payment_date - i.invoice_date), 1) AS avg_dso\n  FROM div_14.finance_ar_invoices i\n  JOIN div_14.finance_ar_payments p ON p.ar_invoice_id = i.ar_invoice_id\n  JOIN div_14.customers c ON c.customer_id = i.customer_id\n  WHERE EXTRACT(YEAR FROM i.invoice_date) = 2024\n  GROUP BY c.name\n  ORDER BY avg_dso DESC;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 14066,
      "tags": "finance,ar,kpi"
    },
    {
      "qid": "Q0072",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Sales order counts by status for 2024.",
      "target_schema": "div_07",
      "sql_generated": "SELECT status, COUNT(order_id) AS order_count FROM sales_orders WHERE EXTRACT(YEAR FROM order_date) = 2024 GROUP BY status LIMIT 1000;",
      "gold_sql": "  SELECT status, COUNT(*) AS order_count\n  FROM div_07.sales_orders\n  WHERE EXTRACT(YEAR FROM order_date) = 2024\n  GROUP BY status;",
      "success": true,
      "latency_ms": 3633,
      "tags": "sales"
    },
    {
      "qid": "Q0073",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Weighted average cost per unit by product for 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT p.product_id, p.name, SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0) AS weighted_avg_cost_per_unit \nFROM products p \nJOIN order_lines ol ON p.product_id = ol.product_id \nWHERE EXTRACT(YEAR FROM ol.order_date) = 2024 \nGROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         ROUND(SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0), 2) AS weighted_avg_cost,\n         SUM(ol.quantity) AS total_units\n  FROM div_06.order_lines ol\n  JOIN div_06.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_06.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY p.name\n  ORDER BY weighted_avg_cost DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 16886,
      "tags": "finance,jargon"
    },
    {
      "qid": "Q0074",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_13.",
      "target_schema": "div_13",
      "sql_generated": "SELECT payment_method_code, SUM(total_amount) AS total_sales FROM rtl_pos_transactions WHERE payment_method_code IN ('CASH', 'CC', 'DC', 'GC', 'MW') GROUP BY payment_method_code LIMIT 1000;",
      "gold_sql": "  SELECT payment_method_code, COUNT(*) AS txn_count,\n         SUM(total_amount) AS total_sales\n  FROM div_13.rtl_pos_transactions\n  GROUP BY payment_method_code\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6957,
      "tags": "retail"
    },
    {
      "qid": "Q0075",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_12",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_12.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 2519,
      "tags": "support"
    },
    {
      "qid": "Q0076",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average discount percentage on sales order lines in 2024.",
      "target_schema": "div_20",
      "sql_generated": "SELECT AVG(discount_percent) AS avg_discount_percentage FROM order_lines WHERE EXTRACT(YEAR FROM order_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(ol.discount_percent), 2) AS avg_discount\n  FROM div_20.order_lines ol\n  JOIN div_20.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"order_date\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 6894,
      "tags": "sales"
    },
    {
      "qid": "Q0077",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee turnover rate for 2021.",
      "target_schema": "div_10",
      "sql_generated": "SELECT AVG(CASE WHEN termination_date BETWEEN '2021-01-01' AND '2021-12-31' THEN 1 ELSE 0 END) AS turnover_rate FROM employees LIMIT 1000;",
      "gold_sql": "  WITH terminations AS (\n    SELECT COUNT(*) AS term_count\n    FROM div_10.employees\n    WHERE EXTRACT(YEAR FROM termination_date) = 2021\n  ),\n  headcount AS (\n    SELECT COUNT(*) AS headcount\n    FROM div_10.employees\n    WHERE hire_date <= DATE '2021-12-31'\n      AND (termination_date IS NULL OR termination_date > DATE '2021-01-01')\n  )\n  SELECT ROUND(100.0 * t.term_count / NULLIF(h.headcount,0), 2) AS turnover_pct\n  FROM terminations t, headcount h;",
      "success": true,
      "latency_ms": 11036,
      "tags": "hr"
    },
    {
      "qid": "Q0078",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS pos_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY pos_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_11.rtl_pos_line_items li\n  JOIN div_11.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 9893,
      "tags": "retail"
    },
    {
      "qid": "Q0079",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 6099,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0080",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List bank accounts with balance under 10000.",
      "target_schema": "div_17",
      "sql_generated": "SELECT account_number, account_name, current_balance FROM bank_accounts WHERE current_balance < 10000 LIMIT 1000;",
      "gold_sql": "  SELECT bank_account_id, account_number, bank_name, current_balance\n  FROM div_17.bank_accounts\n  WHERE current_balance < 10000;",
      "success": true,
      "latency_ms": 3927,
      "tags": "finance"
    },
    {
      "qid": "Q0081",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_13.",
      "target_schema": "div_13",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS total_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_13.rtl_pos_line_items li\n  JOIN div_13.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 9405,
      "tags": "retail"
    },
    {
      "qid": "Q0082",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Compare effective vs statutory tax rate by jurisdiction for corporate division div_20.",
      "target_schema": "div_20",
      "sql_generated": "SELECT jurisdiction, effective_rate, statutory_rate, (effective_rate - statutory_rate) * 100.0 / NULLIF(statutory_rate, 0) AS rate_difference_pct FROM corp_tax_provisions WHERE jurisdiction = 'div_20' LIMIT 1000;",
      "gold_sql": "  SELECT jurisdiction, tax_type,\n         ROUND(AVG(effective_rate), 4) AS avg_effective_rate,\n         ROUND(AVG(statutory_rate), 4) AS avg_statutory_rate,\n         ROUND(AVG(statutory_rate - effective_rate), 4) AS avg_rate_gap,\n         SUM(current_provision + deferred_provision) AS total_provision\n  FROM div_20.corp_tax_provisions\n  GROUP BY jurisdiction, tax_type\n  ORDER BY total_provision DESC;",
      "success": true,
      "latency_ms": 9566,
      "tags": "corporate"
    },
    {
      "qid": "Q0083",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Headcount by department for 2022.",
      "target_schema": "div_01",
      "sql_generated": "SELECT d.name AS department_name, COUNT(e.employee_id) AS headcount FROM departments d JOIN employees e ON d.department_id = e.department_id WHERE EXTRACT(YEAR FROM e.hire_date) = 2022 GROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name, COUNT(*) AS headcount\n  FROM div_01.employees e\n  JOIN div_01.departments d ON d.department_id = e.department_id\n  WHERE EXTRACT(YEAR FROM e.hire_date) <= 2022\n  GROUP BY d.name\n  ORDER BY headcount DESC;",
      "success": true,
      "latency_ms": 6521,
      "tags": "hr"
    },
    {
      "qid": "Q0084",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8126,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0085",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Monthly AR invoice trend with running total for 2021.",
      "target_schema": "div_09",
      "sql_generated": "SELECT date_trunc('month', invoice_date) AS month, amount, SUM(amount) OVER (ORDER BY invoice_date) AS running_total FROM finance_ar_invoices WHERE EXTRACT(YEAR FROM invoice_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT\n    DATE_TRUNC('month', invoice_date) AS month,\n    SUM(amount) AS monthly_amount,\n    SUM(SUM(amount)) OVER (ORDER BY DATE_TRUNC('month', invoice_date)) AS running_total\n  FROM div_09.finance_ar_invoices\n  WHERE EXTRACT(YEAR FROM invoice_date) = 2021\n  GROUP BY month\n  ORDER BY month;",
      "success": true,
      "latency_ms": 10613,
      "tags": "finance,temporal,window"
    },
    {
      "qid": "Q0086",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Approval rate of purchase orders in 2022.",
      "target_schema": "div_08",
      "sql_generated": "SELECT approval_date, SUM(CASE WHEN status = 'Approved' THEN 1 ELSE 0 END) AS approved_count, SUM(CASE WHEN status = 'Rejected' THEN 1 ELSE 0 END) AS rejected_count FROM procurement_po_approvals WHERE EXTRACT(YEAR FROM approval_date) = 2022 GROUP BY approval_date LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) / COUNT(*), 2) AS approval_pct\n  FROM div_08.procurement_po_approvals\n  WHERE EXTRACT(YEAR FROM approval_date) = 2022;",
      "success": true,
      "latency_ms": 12856,
      "tags": "procurement"
    },
    {
      "qid": "Q0087",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Number of comments per support case in 2024.",
      "target_schema": "div_11",
      "sql_generated": "SELECT case_id, COUNT(comment_id) AS comment_count FROM support_ticket_comments WHERE EXTRACT(YEAR FROM comment_ts) = 2024 GROUP BY case_id LIMIT 1000;",
      "gold_sql": "  SELECT case_id, COUNT(*) AS comment_count\n  FROM div_11.support_ticket_comments\n  WHERE EXTRACT(YEAR FROM comment_ts) = 2024\n  GROUP BY case_id;",
      "success": true,
      "latency_ms": 6211,
      "tags": "support"
    },
    {
      "qid": "Q0088",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days between PO order date and goods receipt for each vendor in 2021.",
      "target_schema": "div_15",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, AVG((gr.receipt_date - po.order_date)) AS avg_days_between_po_and_gr FROM purchase_orders po JOIN goods_receipts gr ON po.po_id = gr.po_id JOIN vendors v ON po.vendor_id = v.vendor_id WHERE gr.receipt_date BETWEEN '2021-01-01' AND '2021-12-31' GROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(gr.receipt_date - po.order_date), 2) AS avg_days\n  FROM div_15.purchase_orders po\n  JOIN div_15.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_15.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2021\n  GROUP BY v.name\n  ORDER BY avg_days;",
      "success": true,
      "latency_ms": 15153,
      "tags": "procurement"
    },
    {
      "qid": "Q0089",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Bank transaction totals by type for 2023.",
      "target_schema": "div_06",
      "sql_generated": "SELECT transaction_type, SUM(amount) AS total_amount FROM bank_transactions WHERE EXTRACT(YEAR FROM transaction_date) = 2023 GROUP BY transaction_type LIMIT 1000;",
      "gold_sql": "  SELECT transaction_type, SUM(amount) AS total_amount\n  FROM div_06.bank_transactions\n  WHERE EXTRACT(YEAR FROM transaction_date) = 2023\n  GROUP BY transaction_type;",
      "success": true,
      "latency_ms": 5866,
      "tags": "finance"
    },
    {
      "qid": "Q0090",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Assets transferred between locations in 2023.",
      "target_schema": "div_18",
      "sql_generated": "SELECT at.transfer_id, fa.asset_tag, al1.name AS from_location, al2.name AS to_location, at.transfer_date, at.reason, at.transferred_by FROM asset_transfers at JOIN fixed_assets fa ON at.asset_id = fa.asset_id JOIN asset_locations al1 ON at.from_location_id = al1.location_id JOIN asset_locations al2 ON at.to_location_id = al2.location_id WHERE EXTRACT(YEAR FROM at.transfer_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT transfer_id, asset_id, from_location_id, to_location_id, transfer_date\n  FROM div_18.asset_transfers\n  WHERE EXTRACT(YEAR FROM transfer_date) = 2023;",
      "success": true,
      "latency_ms": 13412,
      "tags": "assets"
    },
    {
      "qid": "Q0091",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Aged AR receivables buckets (0-30, 31-60, 61-90, 90+) for 2023.",
      "target_schema": "div_07",
      "sql_generated": "SELECT \n    CASE \n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '0 days' AND INTERVAL '30 days' THEN '0-30'\n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '31 days' AND INTERVAL '60 days' THEN '31-60'\n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '61 days' AND INTERVAL '90 days' THEN '61-90'\n        ELSE '90+'\n    END AS age_bucket, \n    COUNT(*) AS count \nFROM \n    finance_ar_invoices \nWHERE \n    status = 'open' \n    AND EXTRACT(YEAR FROM invoice_date) = 2023 \nGROUP BY \n    age_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN CURRENT_DATE - due_date <= 30 THEN '0-30'\n      WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'\n      WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'\n      ELSE '90+'\n    END AS aging_bucket,\n    COUNT(*) AS invoice_count,\n    SUM(amount) AS total_amount\n  FROM div_07.finance_ar_invoices\n  WHERE status = 'open'\n    AND EXTRACT(YEAR FROM invoice_date) = 2023\n  GROUP BY aging_bucket\n  ORDER BY aging_bucket;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: operator does not exist: integer >= interval",
      "sqlstate": "42883",
      "latency_ms": 26136,
      "tags": "finance,ar,aging"
    },
    {
      "qid": "Q0092",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2021.",
      "target_schema": "div_10",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.region_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2021\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_10.sales_orders so\n  JOIN div_10.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_10.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_10.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_10.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 20645,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0093",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_07.",
      "target_schema": "div_07",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_07.zz_svc_sow sow\n  JOIN div_07.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 7663,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0094",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total maintenance cost by asset category in 2024.",
      "target_schema": "div_03",
      "sql_generated": "SELECT ac.name AS category_name, SUM(am.cost) AS total_cost FROM asset_maintenance am JOIN fixed_assets fa ON am.asset_id = fa.asset_id JOIN asset_categories ac ON fa.category_id = ac.category_id WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2024 GROUP BY ac.name LIMIT 1000;",
      "gold_sql": "  SELECT ac.name, SUM(am.cost) AS total_cost\n  FROM div_03.asset_maintenance am\n  JOIN div_03.fixed_assets fa ON fa.asset_id = am.asset_id\n  JOIN div_03.asset_categories ac ON ac.category_id = fa.category_id\n  WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2024\n  GROUP BY ac.name;",
      "success": true,
      "latency_ms": 10475,
      "tags": "assets"
    },
    {
      "qid": "Q0095",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total depreciation by period for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT fpe.period_number, SUM(de.amount) AS total_depreciation FROM depreciation_entries de JOIN fiscal_periods fpe ON de.period_id = fpe.period_id WHERE fpe.fiscal_year_id = 2024 GROUP BY fpe.period_number LIMIT 1000;",
      "gold_sql": "  SELECT fp.start_date, SUM(de.amount) AS total_depr\n  FROM div_12.depreciation_entries de\n  JOIN div_12.fiscal_periods fp ON fp.period_id = de.period_id\n  WHERE EXTRACT(YEAR FROM fp.start_date) = 2024\n  GROUP BY fp.start_date\n  ORDER BY fp.start_date;",
      "success": true,
      "latency_ms": 9147,
      "tags": "assets,finance"
    },
    {
      "qid": "Q0096",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Promotion effectiveness: average discount and transaction count per active promotion for div_13.",
      "target_schema": "div_13",
      "sql_generated": "SELECT p.promotion_id, p.promotion_name, AVG(pli.discount_amount) AS avg_discount, COUNT(pli.transaction_id) AS txn_count FROM rtl_pos_line_items pli JOIN rtl_promotions p ON pli.promotion_code = p.promotion_code WHERE p.status_code = 'Active' GROUP BY p.promotion_id, p.promotion_name LIMIT 1000;",
      "gold_sql": "  SELECT pr.promotion_name, pr.discount_type_code,\n         COUNT(*) AS line_items,\n         ROUND(AVG(li.discount_amount), 2) AS avg_discount\n  FROM div_13.rtl_pos_line_items li\n  JOIN div_13.rtl_promotions pr ON pr.promotion_code = li.promotion_code\n  WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL\n  GROUP BY pr.promotion_name, pr.discount_type_code\n  ORDER BY line_items DESC;",
      "success": true,
      "latency_ms": 10867,
      "tags": "retail"
    },
    {
      "qid": "Q0097",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_15.",
      "target_schema": "div_15",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_15.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6624,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0098",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Headcount by department for 2023.",
      "target_schema": "div_03",
      "sql_generated": "SELECT d.name AS department_name, COUNT(e.employee_id) AS headcount FROM departments d JOIN employees e ON d.department_id = e.department_id WHERE EXTRACT(YEAR FROM e.hire_date) = 2023 GROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name, COUNT(*) AS headcount\n  FROM div_03.employees e\n  JOIN div_03.departments d ON d.department_id = e.department_id\n  WHERE EXTRACT(YEAR FROM e.hire_date) <= 2023\n  GROUP BY d.name\n  ORDER BY headcount DESC;",
      "success": true,
      "latency_ms": 8417,
      "tags": "hr"
    },
    {
      "qid": "Q0099",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from RFQ to vendor response for 2022.",
      "target_schema": "div_03",
      "sql_generated": "SELECT AVG(EXTRACT(DAY FROM (responses.response_date - rfqs.rfq_date))) AS avg_days_to_response \nFROM procurement_rfqs rfqs \nJOIN procurement_rfq_responses responses ON rfqs.rfq_id = responses.rfq_id \nWHERE EXTRACT(YEAR FROM responses.response_date) = 2022 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(r.response_date - q.rfq_date), 2) AS avg_days\n  FROM div_03.procurement_rfqs q\n  JOIN div_03.procurement_rfq_responses r ON r.rfq_id = q.rfq_id\n  WHERE EXTRACT(YEAR FROM q.rfq_date) = 2022;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: function pg_catalog.extract(unknown, integer) does not exist",
      "sqlstate": "42883",
      "latency_ms": 10166,
      "tags": "procurement,time"
    },
    {
      "qid": "Q0100",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Procure-to-pay cycle: PO to receipt to invoice for each vendor in 2022.",
      "target_schema": "div_19",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, SUM(po.subtotal) AS total_po_amount, SUM(gr.received_by) AS total_receipts, SUM(vi.total) AS total_invoice_amount \nFROM purchase_orders po \nJOIN goods_receipts gr ON po.po_id = gr.po_id \nJOIN vendor_invoices vi ON gr.receipt_id = vi.receipt_id \nJOIN vendors v ON vi.vendor_id = v.vendor_id \nWHERE EXTRACT(YEAR FROM po.order_date) = 2022 \nGROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name AS vendor,\n         po.po_id,\n         po.order_date,\n         gr.receipt_id,\n         gr.receipt_date,\n         vi.invoice_id,\n         vi.invoice_date,\n         vi.total AS invoice_total\n  FROM div_19.purchase_orders po\n  JOIN div_19.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_19.vendor_invoices vi ON vi.po_id = po.po_id\n  JOIN div_19.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2022\n  ORDER BY po.order_date\n  LIMIT 50;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column vi.receipt_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 21614,
      "tags": "procurement,multi_join"
    },
    {
      "qid": "Q0101",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.region_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2024\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_06.sales_orders so\n  JOIN div_06.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_06.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_06.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_06.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 20935,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0102",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Project profitability: budget vs actual with milestones and timesheets for 2022.",
      "target_schema": "div_19",
      "sql_generated": "SELECT p.project_id, p.name AS project_name, pb.planned_amount, SUM(pe.amount) AS actual_expenses, SUM(te.hours * tr.hourly_rate) AS total_timesheet_cost, (SUM(pe.amount) + SUM(te.hours * tr.hourly_rate)) - pb.planned_amount AS profitability \nFROM projects p \nJOIN project_budgets pb ON p.project_id = pb.project_id \nLEFT JOIN project_expenses pe ON p.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2022 \nLEFT JOIN timesheets ts ON p.project_id = ts.project_id AND EXTRACT(YEAR FROM ts.week_start_date) = 2022 \nLEFT JOIN timesheet_entries te ON ts.timesheet_id = te.timesheet_id \nLEFT JOIN project_resources tr ON p.project_id = tr.project_id \nGROUP BY p.project_id, p.name, pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         pb.planned_amount AS budget,\n         COALESCE(SUM(DISTINCT pe.amount), 0) AS total_expenses,\n         COALESCE(SUM(te.hours), 0) AS total_hours,\n         pb.planned_amount - COALESCE(SUM(DISTINCT pe.amount), 0) AS profit_margin\n  FROM div_19.projects p\n  JOIN div_19.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_19.project_expenses pe ON pe.project_id = p.project_id\n  LEFT JOIN div_19.timesheets ts ON ts.employee_id IN (\n    SELECT employee_id FROM div_19.project_resources WHERE project_id = p.project_id\n  )\n  LEFT JOIN div_19.timesheet_entries te ON te.timesheet_id = ts.timesheet_id\n  WHERE EXTRACT(YEAR FROM p.start_date) = 2022\n  GROUP BY p.name, pb.planned_amount\n  ORDER BY profit_margin DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ts.project_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 32041,
      "tags": "projects,multi_join"
    },
    {
      "qid": "Q0103",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_10.svc_statements_of_work sow\n  JOIN div_10.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": true,
      "latency_ms": 11657,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0104",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "QC failure rate for inventory lots in 2024.",
      "target_schema": "div_20",
      "sql_generated": "SELECT lot_id, COUNT(*) FILTER (WHERE result = 'fail') AS fail_count, COUNT(*) AS total_count, (COUNT(*) FILTER (WHERE result = 'fail') * 100.0 / NULLIF(COUNT(*), 0)) AS failure_rate FROM inventory_qc_inspections WHERE EXTRACT(YEAR FROM inspection_date) = 2024 GROUP BY lot_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN qi.result = 'fail' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_pct\n  FROM div_20.inventory_qc_inspections qi\n  WHERE EXTRACT(YEAR FROM qi.inspection_date) = 2024;",
      "success": true,
      "latency_ms": 12863,
      "tags": "inventory,qc"
    },
    {
      "qid": "Q0105",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 7322,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0106",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee utilization rate = hours logged / 40 by week in 2021.",
      "target_schema": "div_19",
      "sql_generated": "SELECT employee_id, SUM(hours) / 40.0 AS utilization_rate FROM timesheet_entries WHERE date_trunc('week', entry_date) BETWEEN '2021-01-01' AND '2021-12-31' GROUP BY employee_id LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, DATE_TRUNC('week', t.week_start_date) AS week_start,\n         ROUND(SUM(te.hours) / 40.0, 2) AS utilization\n  FROM div_19.timesheets t\n  JOIN div_19.timesheet_entries te ON te.timesheet_id = t.timesheet_id\n  JOIN div_19.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.week_start_date) = 2021\n  GROUP BY e.employee_id, week_start;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"employee_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 13362,
      "tags": "projects,hr"
    },
    {
      "qid": "Q0107",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_12.",
      "target_schema": "div_12",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_12.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6700,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0108",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List bank accounts with balance under 500.",
      "target_schema": "div_09",
      "sql_generated": "SELECT account_number, account_name, current_balance FROM bank_accounts WHERE current_balance < 500 LIMIT 1000;",
      "gold_sql": "  SELECT bank_account_id, account_number, bank_name, current_balance\n  FROM div_09.bank_accounts\n  WHERE current_balance < 500;",
      "success": true,
      "latency_ms": 3701,
      "tags": "finance"
    },
    {
      "qid": "Q0109",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inventory lots expiring within 60 days.",
      "target_schema": "div_17",
      "sql_generated": "SELECT lot_id, product_id, warehouse_id, lot_number, received_date, expiration_date, quantity FROM inventory_lots WHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' LIMIT 1000;",
      "gold_sql": "  SELECT lot_id, lot_number, expiration_date\n  FROM div_17.inventory_lots\n  WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';",
      "success": true,
      "latency_ms": 6649,
      "tags": "inventory"
    },
    {
      "qid": "Q0110",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days between PO order date and goods receipt for each vendor in 2023.",
      "target_schema": "div_15",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, AVG((gr.receipt_date - po.order_date)) AS avg_days_between_po_and_gr FROM purchase_orders po JOIN goods_receipts gr ON po.po_id = gr.po_id JOIN vendors v ON po.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM gr.receipt_date) = 2023 GROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(gr.receipt_date - po.order_date), 2) AS avg_days\n  FROM div_15.purchase_orders po\n  JOIN div_15.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_15.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2023\n  GROUP BY v.name\n  ORDER BY avg_days;",
      "success": true,
      "latency_ms": 12676,
      "tags": "procurement"
    },
    {
      "qid": "Q0111",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Timesheets awaiting approval in 2021.",
      "target_schema": "div_07",
      "sql_generated": "SELECT employee_id, week_start_date, total_hours FROM timesheets WHERE status = 'submitted' AND EXTRACT(YEAR FROM submitted_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT timesheet_id, employee_id, week_start_date, status\n  FROM div_07.timesheets\n  WHERE status = 'submitted'\n    AND EXTRACT(YEAR FROM week_start_date) = 2021;",
      "success": true,
      "latency_ms": 8018,
      "tags": "projects"
    },
    {
      "qid": "Q0112",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total SOW contract value by customer for services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.total_amount) AS total_sow_value \nFROM svc_statements_of_work s \nJOIN customers c ON s.customer_id = c.customer_id \nGROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.total_amount) AS total_contract_value, COUNT(*) AS sow_count\n  FROM div_06.svc_statements_of_work sow\n  JOIN div_06.customers c ON c.customer_id = sow.customer_id\n  GROUP BY c.name\n  ORDER BY total_contract_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 10052,
      "tags": "services"
    },
    {
      "qid": "Q0113",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List bank accounts with balance under 5000.",
      "target_schema": "div_13",
      "sql_generated": "SELECT account_number, account_name, current_balance FROM bank_accounts WHERE current_balance < 5000 LIMIT 1000;",
      "gold_sql": "  SELECT bank_account_id, account_number, bank_name, current_balance\n  FROM div_13.bank_accounts\n  WHERE current_balance < 5000;",
      "success": true,
      "latency_ms": 3799,
      "tags": "finance"
    },
    {
      "qid": "Q0114",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 5298,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0115",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Sales order counts by status for 2022.",
      "target_schema": "div_09",
      "sql_generated": "SELECT status, COUNT(order_id) AS count FROM sales_orders WHERE order_date >= '2022-01-01' AND order_date < '2023-01-01' GROUP BY status LIMIT 1000;",
      "gold_sql": "  SELECT status, COUNT(*) AS order_count\n  FROM div_09.sales_orders\n  WHERE EXTRACT(YEAR FROM order_date) = 2022\n  GROUP BY status;",
      "success": true,
      "latency_ms": 6444,
      "tags": "sales"
    },
    {
      "qid": "Q0116",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inactive vendors.",
      "target_schema": "div_08",
      "sql_generated": "SELECT vendor_id, name, email, phone, website FROM vendors WHERE is_active = false LIMIT 1000;",
      "gold_sql": "  SELECT vendor_id, name\n  FROM div_08.vendors\n  WHERE is_active = FALSE;",
      "success": true,
      "latency_ms": 4379,
      "tags": "procurement"
    },
    {
      "qid": "Q0117",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales orders shipped after ship_date in 2024.",
      "target_schema": "div_02",
      "sql_generated": "SELECT * FROM sales_orders WHERE ship_date > '2023-12-31' AND ship_date < '2025-01-01' LIMIT 1000;",
      "gold_sql": "  SELECT order_id, customer_id, order_date, ship_date\n  FROM div_02.sales_orders\n  WHERE ship_date IS NOT NULL\n    AND ship_date > order_date\n    AND EXTRACT(YEAR FROM order_date) = 2024;",
      "success": true,
      "latency_ms": 6794,
      "tags": "sales"
    },
    {
      "qid": "Q0118",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales orders shipped after ship_date in 2022.",
      "target_schema": "div_03",
      "sql_generated": "SELECT * FROM sales_orders WHERE ship_date > '2021-12-31' AND ship_date < '2023-01-01' LIMIT 1000;",
      "gold_sql": "  SELECT order_id, customer_id, order_date, ship_date\n  FROM div_03.sales_orders\n  WHERE ship_date IS NOT NULL\n    AND ship_date > order_date\n    AND EXTRACT(YEAR FROM order_date) = 2022;",
      "success": true,
      "latency_ms": 5869,
      "tags": "sales"
    },
    {
      "qid": "Q0119",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Promotion effectiveness: average discount and transaction count per active promotion for div_15.",
      "target_schema": "div_15",
      "sql_generated": "SELECT p.promotion_name, AVG(li.discount_amount) AS avg_discount, COUNT(li.line_id) AS txn_count FROM rtl_pos_line_items li JOIN rtl_promotions p ON li.promotion_code = p.promotion_code WHERE p.status_code = 'Active' GROUP BY p.promotion_name LIMIT 1000;",
      "gold_sql": "  SELECT pr.promotion_name, pr.discount_type_code,\n         COUNT(*) AS line_items,\n         ROUND(AVG(li.discount_amount), 2) AS avg_discount\n  FROM div_15.rtl_pos_line_items li\n  JOIN div_15.rtl_promotions pr ON pr.promotion_code = li.promotion_code\n  WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL\n  GROUP BY pr.promotion_name, pr.discount_type_code\n  ORDER BY line_items DESC;",
      "success": true,
      "latency_ms": 8344,
      "tags": "retail"
    },
    {
      "qid": "Q0120",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Cost of goods sold by product line for 2021.",
      "target_schema": "div_10",
      "sql_generated": "SELECT p.product_id, p.name AS product_name, SUM(ol.quantity_shipped * p.list_price * (p.unit_cost / p.list_price)) AS cogs FROM sales_orders so JOIN order_lines ol ON so.order_id = ol.order_id JOIN products p ON ol.product_id = p.product_id WHERE EXTRACT(YEAR FROM so.order_date) = 2021 GROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name AS product_line,\n         SUM(ol.quantity * ol.unit_price) AS total_revenue,\n         COUNT(DISTINCT so.order_id) AS order_count\n  FROM div_10.order_lines ol\n  JOIN div_10.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_10.products p ON p.product_id = ol.product_id\n  JOIN div_10.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY pc.name\n  ORDER BY total_revenue DESC;",
      "success": true,
      "latency_ms": 12889,
      "tags": "finance,kpi"
    },
    {
      "qid": "Q0121",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Show onboarding tasks overdue as of today.",
      "target_schema": "div_11",
      "sql_generated": "SELECT task_id, name, description, due_date, completed_date, status FROM project_tasks WHERE status != 'Done' AND due_date < CURRENT_DATE LIMIT 1000;",
      "gold_sql": "  SELECT task_id, employee_id, task_name, due_date, status\n  FROM div_11.hr_onboarding_tasks\n  WHERE status <> 'done'\n    AND due_date < CURRENT_DATE;",
      "success": true,
      "latency_ms": 5952,
      "tags": "hr"
    },
    {
      "qid": "Q0122",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Benefit election count by coverage level in 2023.",
      "target_schema": "div_11",
      "sql_generated": "SELECT coverage_level, COUNT(*) AS benefit_election_count FROM hr_benefit_elections WHERE EXTRACT(YEAR FROM election_date) = 2023 GROUP BY coverage_level LIMIT 1000;",
      "gold_sql": "  SELECT coverage_level, COUNT(*) AS elections\n  FROM div_11.hr_benefit_elections\n  WHERE EXTRACT(YEAR FROM election_date) = 2023\n  GROUP BY coverage_level;",
      "success": true,
      "latency_ms": 5943,
      "tags": "hr,benefits"
    },
    {
      "qid": "Q0123",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average time to close support cases in 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT AVG(updated_at - opened_at) AS avg_time_to_close FROM cust_srv_case WHERE EXTRACT(YEAR FROM opened_at) = 2021 AND status = 'Closed' LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - opened_at)) / 3600), 2) AS avg_close_hours\n  FROM div_05.cust_srv_case\n  WHERE status = 'closed'\n    AND EXTRACT(YEAR FROM opened_at) = 2021;",
      "success": true,
      "latency_ms": 4686,
      "tags": "support"
    },
    {
      "qid": "Q0124",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average allocation percent by project in 2023.",
      "target_schema": "div_19",
      "sql_generated": "SELECT p.project_id, AVG(pr.allocation_percent) AS avg_allocation_percent \nFROM projects p \nJOIN project_resources pr ON p.project_id = pr.project_id \nWHERE EXTRACT(YEAR FROM pr.start_date) = 2023 \nGROUP BY p.project_id LIMIT 1000;",
      "gold_sql": "  SELECT p.name, ROUND(AVG(pr.allocation_percent), 2) AS avg_alloc\n  FROM div_19.project_resources pr\n  JOIN div_19.projects p ON p.project_id = pr.project_id\n  WHERE EXTRACT(YEAR FROM p.start_date) = 2023\n  GROUP BY p.name;",
      "success": true,
      "latency_ms": 9630,
      "tags": "projects"
    },
    {
      "qid": "Q0125",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2021.",
      "target_schema": "div_16",
      "sql_generated": "SELECT pc.name AS category_name, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS turns_per_month FROM inventory_transactions it JOIN products p ON it.product_id = p.product_id JOIN product_categories pc ON p.category_id = pc.category_id WHERE date_trunc('year', it.transaction_date) = '2021-01-01' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_16.inventory_transactions it\n  JOIN div_16.products p ON p.product_id = it.product_id\n  JOIN div_16.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2021\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 13128,
      "tags": "inventory"
    },
    {
      "qid": "Q0126",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from requisition to PO for 2021.",
      "target_schema": "div_09",
      "sql_generated": "SELECT AVG(DATE_PART('day', po.order_date - pr.request_date)) AS avg_days_to_po \nFROM purchase_requisitions pr \nJOIN purchase_orders po ON pr.requisition_id = po.requisition_id \nWHERE EXTRACT(YEAR FROM pr.request_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(po.order_date - pr.request_date), 2) AS avg_days\n  FROM div_09.purchase_requisitions pr\n  JOIN div_09.purchase_orders po ON po.requisition_id = pr.requisition_id\n  WHERE EXTRACT(YEAR FROM pr.request_date) = 2021;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: function date_part(unknown, integer) does not exist",
      "sqlstate": "42883",
      "latency_ms": 9550,
      "tags": "procurement"
    },
    {
      "qid": "Q0127",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Workflow approval counts by decoded approval status.",
      "target_schema": "div_08",
      "sql_generated": "",
      "gold_sql": "  SELECT status, COUNT(*) AS step_count\n  FROM div_08.wf_approval_step\n  GROUP BY status\n  ORDER BY step_count DESC;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 8581,
      "tags": "workflow,lookup"
    },
    {
      "qid": "Q0128",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee tenure distribution (0-1yr, 1-3yr, 3-5yr, 5+yr) as of 2021.",
      "target_schema": "div_19",
      "sql_generated": "SELECT CASE WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 0 AND 1 THEN '0-1yr' WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 1 AND 3 THEN '1-3yr' WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 3 AND 5 THEN '3-5yr' ELSE '5+yr' END AS tenure_bucket, COUNT(*) AS employee_count FROM employees WHERE termination_date IS NULL OR termination_date > '2021-12-31' GROUP BY tenure_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 1 THEN '0-1 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 3 THEN '1-3 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 5 THEN '3-5 yr'\n      ELSE '5+ yr'\n    END AS tenure_bucket,\n    COUNT(*) AS employee_count\n  FROM div_19.employees\n  WHERE hire_date <= DATE '2021-12-31'\n    AND (termination_date IS NULL OR termination_date > DATE '2021-12-31')\n  GROUP BY tenure_bucket\n  ORDER BY tenure_bucket;",
      "success": true,
      "latency_ms": 20417,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0129",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 5198,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0130",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Period-over-period headcount change by month for 2024.",
      "target_schema": "div_18",
      "sql_generated": "SELECT \n    date_trunc('month', e.hire_date) AS month,\n    COUNT(e.employee_id) AS headcount\nFROM \n    employees e\nWHERE \n    e.termination_date IS NULL AND\n    e.hire_date <= '2024-12-31'\nGROUP BY \n    month\nORDER BY \n    month LIMIT 1000;",
      "gold_sql": "  WITH months AS (\n    SELECT generate_series(1, 12) AS month_num\n  ),\n  headcount AS (\n    SELECT m.month_num,\n           COUNT(*) AS hc\n    FROM months m\n    JOIN div_18.employees e ON e.hire_date <= DATE '2024-12-31'\n      AND (DATE '2024-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date\n      AND (e.termination_date IS NULL\n           OR e.termination_date > DATE '2024-01-01' + (m.month_num - 1) * INTERVAL '1 month')\n    GROUP BY m.month_num\n  )\n  SELECT month_num, hc,\n         hc - LAG(hc) OVER (ORDER BY month_num) AS change\n  FROM headcount\n  ORDER BY month_num;",
      "success": true,
      "latency_ms": 19232,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0131",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee utilization rate = hours logged / 40 by week in 2024.",
      "target_schema": "div_19",
      "sql_generated": "SELECT employee_id, SUM(hours) AS total_hours, COUNT(*) AS entry_count, (SUM(hours) * 100.0 / NULLIF(COUNT(*), 0)) AS utilization_rate FROM timesheet_entries WHERE EXTRACT(YEAR FROM week_start_date) = 2024 GROUP BY employee_id LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, DATE_TRUNC('week', t.week_start_date) AS week_start,\n         ROUND(SUM(te.hours) / 40.0, 2) AS utilization\n  FROM div_19.timesheets t\n  JOIN div_19.timesheet_entries te ON te.timesheet_id = t.timesheet_id\n  JOIN div_19.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.week_start_date) = 2024\n  GROUP BY e.employee_id, week_start;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"employee_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 12190,
      "tags": "projects,hr"
    },
    {
      "qid": "Q0132",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Benefit election count by coverage level in 2022.",
      "target_schema": "div_01",
      "sql_generated": "SELECT coverage_level, COUNT(*) AS benefit_election_count FROM hr_benefit_elections WHERE DATE_TRUNC('year', election_date) = '2022-01-01' GROUP BY coverage_level LIMIT 1000;",
      "gold_sql": "  SELECT coverage_level, COUNT(*) AS elections\n  FROM div_01.hr_benefit_elections\n  WHERE EXTRACT(YEAR FROM election_date) = 2022\n  GROUP BY coverage_level;",
      "success": true,
      "latency_ms": 6510,
      "tags": "hr,benefits"
    },
    {
      "qid": "Q0133",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Assets transferred between locations in 2023.",
      "target_schema": "div_13",
      "sql_generated": "SELECT at.transfer_id, fa.asset_tag, al1.name AS from_location, al2.name AS to_location, at.transfer_date, at.reason, at.transferred_by FROM asset_transfers at JOIN fixed_assets fa ON at.asset_id = fa.asset_id JOIN asset_locations al1 ON at.from_location_id = al1.location_id JOIN asset_locations al2 ON at.to_location_id = al2.location_id WHERE EXTRACT(YEAR FROM at.transfer_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT transfer_id, asset_id, from_location_id, to_location_id, transfer_date\n  FROM div_13.asset_transfers\n  WHERE EXTRACT(YEAR FROM transfer_date) = 2023;",
      "success": true,
      "latency_ms": 15200,
      "tags": "assets"
    },
    {
      "qid": "Q0134",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from requisition to PO for 2024.",
      "target_schema": "div_04",
      "sql_generated": "SELECT AVG(po.order_date - pr.request_date) AS avg_days_to_po FROM purchase_requisitions pr JOIN purchase_orders po ON pr.requisition_id = po.requisition_id WHERE EXTRACT(YEAR FROM po.order_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(po.order_date - pr.request_date), 2) AS avg_days\n  FROM div_04.purchase_requisitions pr\n  JOIN div_04.purchase_orders po ON po.requisition_id = pr.requisition_id\n  WHERE EXTRACT(YEAR FROM pr.request_date) = 2024;",
      "success": true,
      "latency_ms": 7818,
      "tags": "procurement"
    },
    {
      "qid": "Q0135",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_13.",
      "target_schema": "div_13",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS total_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_13.rtl_pos_line_items li\n  JOIN div_13.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 10798,
      "tags": "retail"
    },
    {
      "qid": "Q0136",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average resource allocation percent by role for active SOWs in services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT r.role_name, AVG(r.allocation_percent) AS avg_allocation\nFROM svc_resource_plan r\nJOIN svc_statements_of_work s ON r.sow_id = s.sow_id\nWHERE s.status_code = 'AC'\nGROUP BY r.role_name LIMIT 1000;",
      "gold_sql": "  SELECT rp.role_name,\n         ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,\n         COUNT(*) AS assignments\n  FROM div_06.svc_resource_plan rp\n  JOIN div_06.svc_statements_of_work sow ON sow.sow_id = rp.sow_id\n  WHERE sow.status_code = 'AC'\n  GROUP BY rp.role_name\n  ORDER BY avg_allocation DESC;",
      "success": true,
      "latency_ms": 9300,
      "tags": "services,kpi"
    },
    {
      "qid": "Q0137",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_02.",
      "target_schema": "div_02",
      "sql_generated": "SELECT l.meaning AS status, COUNT(w.wo_id) AS work_order_count \nFROM xx_mfg_wo w \nJOIN lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_02.xx_mfg_wo wo\n  JOIN div_02.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": true,
      "latency_ms": 9176,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0138",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total depreciation by period for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT fpe.period_number, SUM(de.amount) AS total_depreciation FROM depreciation_entries de JOIN fiscal_periods fpe ON de.period_id = fpe.period_id WHERE fpe.fiscal_year_id = 2024 GROUP BY fpe.period_number LIMIT 1000;",
      "gold_sql": "  SELECT fp.start_date, SUM(de.amount) AS total_depr\n  FROM div_12.depreciation_entries de\n  JOIN div_12.fiscal_periods fp ON fp.period_id = de.period_id\n  WHERE EXTRACT(YEAR FROM fp.start_date) = 2024\n  GROUP BY fp.start_date\n  ORDER BY fp.start_date;",
      "success": true,
      "latency_ms": 9123,
      "tags": "assets,finance"
    },
    {
      "qid": "Q0139",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average time to close support cases in 2021.",
      "target_schema": "div_15",
      "sql_generated": "SELECT AVG(updated_at - opened_at) AS avg_time_to_close FROM cust_srv_case WHERE EXTRACT(YEAR FROM opened_at) = 2021 AND status = 'Closed' LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - opened_at)) / 3600), 2) AS avg_close_hours\n  FROM div_15.cust_srv_case\n  WHERE status = 'closed'\n    AND EXTRACT(YEAR FROM opened_at) = 2021;",
      "success": true,
      "latency_ms": 6727,
      "tags": "support"
    },
    {
      "qid": "Q0140",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Open audit findings by severity and type for corporate division div_18.",
      "target_schema": "div_18",
      "sql_generated": "SELECT severity, type, COUNT(*) AS finding_count\nFROM corp_audit_findings\nWHERE status_code IN ('OP', 'IP')\nAND department_id = (SELECT department_id FROM departments WHERE division = 'div_18')\nGROUP BY severity, type;",
      "gold_sql": "  SELECT audit_type, severity, COUNT(*) AS finding_count\n  FROM div_18.corp_audit_findings\n  WHERE status_code IN ('OP', 'IP')\n  GROUP BY audit_type, severity\n  ORDER BY severity, finding_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 9455,
      "tags": "corporate"
    },
    {
      "qid": "Q0141",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Vendors with payment terms of 30 days or more.",
      "target_schema": "div_16",
      "sql_generated": "SELECT vendor_id, name, payment_terms FROM vendors WHERE payment_terms >= 30 LIMIT 1000;",
      "gold_sql": "  SELECT vendor_id, name, payment_terms\n  FROM div_16.vendors\n  WHERE payment_terms >= 30;",
      "success": true,
      "latency_ms": 1912,
      "tags": "procurement"
    },
    {
      "qid": "Q0142",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Aged AR receivables buckets (0-30, 31-60, 61-90, 90+) for 2022.",
      "target_schema": "div_07",
      "sql_generated": "SELECT CASE WHEN invoice_date >= CURRENT_DATE - INTERVAL '30 days' THEN '0-30' WHEN invoice_date < CURRENT_DATE - INTERVAL '30 days' AND invoice_date >= CURRENT_DATE - INTERVAL '60 days' THEN '31-60' WHEN invoice_date < CURRENT_DATE - INTERVAL '60 days' AND invoice_date >= CURRENT_DATE - INTERVAL '90 days' THEN '61-90' ELSE '90+' END AS age_bucket, COUNT(*) AS count FROM finance_ar_invoices WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = 2022 GROUP BY age_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN CURRENT_DATE - due_date <= 30 THEN '0-30'\n      WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'\n      WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'\n      ELSE '90+'\n    END AS aging_bucket,\n    COUNT(*) AS invoice_count,\n    SUM(amount) AS total_amount\n  FROM div_07.finance_ar_invoices\n  WHERE status = 'open'\n    AND EXTRACT(YEAR FROM invoice_date) = 2022\n  GROUP BY aging_bucket\n  ORDER BY aging_bucket;",
      "success": true,
      "latency_ms": 21110,
      "tags": "finance,ar,aging"
    },
    {
      "qid": "Q0143",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2021.",
      "target_schema": "div_11",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.region_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2021\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_11.sales_orders so\n  JOIN div_11.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_11.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_11.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_11.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 20517,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0144",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average resource allocation percent by role for active SOWs in services division div_08.",
      "target_schema": "div_08",
      "sql_generated": "SELECT r.role_name, AVG(r.allocation_percent) AS avg_allocation_percent\nFROM svc_resource_plan r\nJOIN svc_statements_of_work s ON r.sow_id = s.sow_id\nWHERE s.status_code = 'AC'\nGROUP BY r.role_name LIMIT 1000;",
      "gold_sql": "  SELECT rp.role_name,\n         ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,\n         COUNT(*) AS assignments\n  FROM div_08.svc_resource_plan rp\n  JOIN div_08.svc_statements_of_work sow ON sow.sow_id = rp.sow_id\n  WHERE sow.status_code = 'AC'\n  GROUP BY rp.role_name\n  ORDER BY avg_allocation DESC;",
      "success": true,
      "latency_ms": 9380,
      "tags": "services,kpi"
    },
    {
      "qid": "Q0145",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Training completion rate by course for 2023.",
      "target_schema": "div_10",
      "sql_generated": "SELECT tc.course_id, tc.name, COUNT(et.employee_id) AS completed_count, COUNT(*) AS total_enrollments, (COUNT(et.employee_id) * 100.0 / NULLIF(COUNT(*), 0)) AS completion_rate FROM training_courses tc LEFT JOIN employee_training et ON tc.course_id = et.course_id AND et.completion_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY tc.course_id, tc.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, COUNT(*) AS completions\n  FROM div_10.employee_training et\n  JOIN div_10.training_courses c ON c.course_id = et.course_id\n  WHERE EXTRACT(YEAR FROM et.completion_date) = 2023\n  GROUP BY c.name\n  ORDER BY completions DESC;",
      "success": true,
      "latency_ms": 14697,
      "tags": "hr,training"
    },
    {
      "qid": "Q0146",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_09.",
      "target_schema": "div_09",
      "sql_generated": "SELECT c.customer_id, c.name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_09.zz_svc_sow sow\n  JOIN div_09.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 8219,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0147",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 7365,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0148",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Timesheets awaiting approval in 2022.",
      "target_schema": "div_12",
      "sql_generated": "SELECT employee_id, week_start_date, total_hours FROM timesheets WHERE status = 'submitted' AND EXTRACT(YEAR FROM submitted_date) = 2022 LIMIT 1000;",
      "gold_sql": "  SELECT timesheet_id, employee_id, week_start_date, status\n  FROM div_12.timesheets\n  WHERE status = 'submitted'\n    AND EXTRACT(YEAR FROM week_start_date) = 2022;",
      "success": true,
      "latency_ms": 6587,
      "tags": "projects"
    },
    {
      "qid": "Q0149",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turnover ratio by product category for 2021.",
      "target_schema": "div_09",
      "sql_generated": "SELECT \n    pc.name AS category_name,\n    SUM(it.quantity) / NULLIF(AVG(il.quantity_on_hand), 0) AS turnover_ratio\nFROM \n    inventory_transactions it\nJOIN \n    products p ON it.product_id = p.product_id\nJOIN \n    product_categories pc ON p.category_id = pc.category_id\nJOIN \n    inventory_levels il ON p.product_id = il.product_id AND it.warehouse_id = il.warehouse_id\nWHERE \n    EXTRACT(YEAR FROM it.transaction_date) = 2021\nGROUP BY \n    pc.name;",
      "gold_sql": "  SELECT pc.name,\n         SUM(ABS(it.quantity)) AS total_moved,\n         AVG(il.quantity_on_hand) AS avg_on_hand,\n         ROUND(SUM(ABS(it.quantity)) / NULLIF(AVG(il.quantity_on_hand), 0), 2) AS turnover_ratio\n  FROM div_09.inventory_transactions it\n  JOIN div_09.products p ON p.product_id = it.product_id\n  JOIN div_09.product_categories pc ON pc.category_id = p.category_id\n  LEFT JOIN div_09.inventory_levels il ON il.product_id = p.product_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2021\n  GROUP BY pc.name\n  ORDER BY turnover_ratio DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21101,
      "tags": "inventory,kpi"
    },
    {
      "qid": "Q0150",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT pc.name AS category_name, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS turns_per_month FROM inventory_transactions it JOIN products p ON it.product_id = p.product_id JOIN product_categories pc ON p.category_id = pc.category_id WHERE date_trunc('year', it.transaction_date) = '2021-01-01' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_05.inventory_transactions it\n  JOIN div_05.products p ON p.product_id = it.product_id\n  JOIN div_05.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2021\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 11047,
      "tags": "inventory"
    },
    {
      "qid": "Q0151",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total scrap quantity by reason for manufacturing division div_05.",
      "target_schema": "div_05",
      "sql_generated": "SELECT reason_code, SUM(scrap_quantity) AS total_scrap_quantity \nFROM mfg_scrap_log \nWHERE work_order_id IN (SELECT work_order_id FROM mfg_work_orders WHERE department_id = 'div_05') \nGROUP BY reason_code LIMIT 1000;",
      "gold_sql": "  SELECT reason_code, SUM(scrap_quantity) AS total_scrap\n  FROM div_05.mfg_scrap_log\n  GROUP BY reason_code\n  ORDER BY total_scrap DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"department_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 12486,
      "tags": "manufacturing"
    },
    {
      "qid": "Q0152",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List open sales opportunities with probability over 0.9.",
      "target_schema": "div_18",
      "sql_generated": "SELECT opportunity_id, name, customer_id, owner_id, stage_id, amount, probability, expected_close_date, actual_close_date, source, created_at FROM sales_opportunities WHERE probability > 0.9 AND is_closed = false LIMIT 1000;",
      "gold_sql": "  SELECT opportunity_id, name, amount, probability\n  FROM div_18.sales_opportunities\n  WHERE probability > 0.9;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"is_closed\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 9976,
      "tags": "sales"
    },
    {
      "qid": "Q0153",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Vendors with payment terms of 30 days or more.",
      "target_schema": "div_15",
      "sql_generated": "SELECT vendor_id, name, payment_terms FROM vendors WHERE payment_terms >= 30 LIMIT 1000;",
      "gold_sql": "  SELECT vendor_id, name, payment_terms\n  FROM div_15.vendors\n  WHERE payment_terms >= 30;",
      "success": true,
      "latency_ms": 3984,
      "tags": "procurement"
    },
    {
      "qid": "Q0154",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Project profitability: budget vs actual with milestones and timesheets for 2022.",
      "target_schema": "div_16",
      "sql_generated": "SELECT p.project_id, p.name AS project_name, pb.planned_amount, SUM(pe.amount) AS actual_expenses, SUM(te.hours * tr.hourly_rate) AS total_hours, SUM(te.hours * tr.hourly_rate) - SUM(pe.amount) AS profitability \nFROM projects p \nJOIN project_budgets pb ON p.project_id = pb.project_id \nLEFT JOIN project_expenses pe ON p.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2022 \nLEFT JOIN timesheets ts ON p.project_id = ts.project_id AND EXTRACT(YEAR FROM ts.week_start_date) = 2022 \nLEFT JOIN timesheet_entries te ON ts.timesheet_id = te.timesheet_id \nLEFT JOIN project_resources tr ON p.project_id = tr.project_id AND EXTRACT(YEAR FROM tr.start_date) = 2022 \nGROUP BY p.project_id, p.name, pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         pb.planned_amount AS budget,\n         COALESCE(SUM(DISTINCT pe.amount), 0) AS total_expenses,\n         COALESCE(SUM(te.hours), 0) AS total_hours,\n         pb.planned_amount - COALESCE(SUM(DISTINCT pe.amount), 0) AS profit_margin\n  FROM div_16.projects p\n  JOIN div_16.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_16.project_expenses pe ON pe.project_id = p.project_id\n  LEFT JOIN div_16.timesheets ts ON ts.employee_id IN (\n    SELECT employee_id FROM div_16.project_resources WHERE project_id = p.project_id\n  )\n  LEFT JOIN div_16.timesheet_entries te ON te.timesheet_id = ts.timesheet_id\n  WHERE EXTRACT(YEAR FROM p.start_date) = 2022\n  GROUP BY p.name, pb.planned_amount\n  ORDER BY profit_margin DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ts.project_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 32367,
      "tags": "projects,multi_join"
    },
    {
      "qid": "Q0155",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Products below reorder minimum by warehouse.",
      "target_schema": "div_19",
      "sql_generated": "SELECT rl.product_id, rl.warehouse_id, il.quantity_on_hand, rl.min_quantity, rl.reorder_quantity FROM reorder_rules rl JOIN inventory_levels il ON rl.product_id = il.product_id AND rl.warehouse_id = il.warehouse_id WHERE il.quantity_on_hand < rl.min_quantity LIMIT 1000;",
      "gold_sql": "  SELECT rr.warehouse_id, p.sku, il.quantity_on_hand, rr.min_quantity\n  FROM div_19.reorder_rules rr\n  JOIN div_19.inventory_levels il ON il.product_id = rr.product_id AND il.warehouse_id = rr.warehouse_id\n  JOIN div_19.products p ON p.product_id = rr.product_id\n  WHERE il.quantity_on_hand < rr.min_quantity;",
      "success": true,
      "latency_ms": 9339,
      "tags": "inventory"
    },
    {
      "qid": "Q0156",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Quote-to-order conversion rate for 2023.",
      "target_schema": "div_01",
      "sql_generated": "SELECT s.quote_id, s.customer_id, COUNT(o.order_id) AS orders_count, COUNT(s.quote_id) AS quotes_count, (COUNT(o.order_id) * 100.0 / NULLIF(COUNT(s.quote_id), 0)) AS conversion_rate FROM sales_quotes s LEFT JOIN sales_orders o ON s.customer_id = o.customer_id AND s.quote_date <= o.order_date AND o.order_date < s.valid_until WHERE EXTRACT(YEAR FROM s.quote_date) = 2023 GROUP BY s.quote_id, s.customer_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * COUNT(DISTINCT so.order_id) / NULLIF(COUNT(DISTINCT sq.quote_id),0), 2) AS conversion_pct\n  FROM div_01.sales_quotes sq\n  LEFT JOIN div_01.sales_orders so ON so.customer_id = sq.customer_id\n  WHERE EXTRACT(YEAR FROM sq.quote_date) = 2023;",
      "success": true,
      "latency_ms": 17127,
      "tags": "sales"
    },
    {
      "qid": "Q0157",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average vendor payment cycle (invoice to payment) by vendor for 2024.",
      "target_schema": "div_15",
      "sql_generated": "SELECT v.vendor_id, AVG(p.payment_date - i.invoice_date) AS avg_payment_cycle FROM finance_ar_invoices i JOIN finance_ar_payments p ON i.ar_invoice_id = p.ar_invoice_id JOIN vendors v ON i.customer_id = v.vendor_id WHERE EXTRACT(YEAR FROM i.invoice_date) = 2024 GROUP BY v.vendor_id LIMIT 1000;",
      "gold_sql": "  SELECT v.name,\n         ROUND(AVG(ai.due_date - ai.invoice_date), 1) AS avg_payment_cycle_days,\n         COUNT(*) AS invoice_count\n  FROM div_15.finance_ap_invoices ai\n  JOIN div_15.vendors v ON v.vendor_id = ai.vendor_id\n  WHERE EXTRACT(YEAR FROM ai.invoice_date) = 2024\n  GROUP BY v.name\n  ORDER BY avg_payment_cycle_days DESC;",
      "success": true,
      "latency_ms": 12599,
      "tags": "procurement,kpi"
    },
    {
      "qid": "Q0158",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average allocation percent by project in 2023.",
      "target_schema": "div_10",
      "sql_generated": "SELECT p.project_id, AVG(pr.allocation_percent) AS avg_allocation_percent \nFROM projects p \nJOIN project_resources pr ON p.project_id = pr.project_id \nWHERE EXTRACT(YEAR FROM pr.start_date) = 2023 \nGROUP BY p.project_id LIMIT 1000;",
      "gold_sql": "  SELECT p.name, ROUND(AVG(pr.allocation_percent), 2) AS avg_alloc\n  FROM div_10.project_resources pr\n  JOIN div_10.projects p ON p.project_id = pr.project_id\n  WHERE EXTRACT(YEAR FROM p.start_date) = 2023\n  GROUP BY p.name;",
      "success": true,
      "latency_ms": 9641,
      "tags": "projects"
    },
    {
      "qid": "Q0159",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top 5 vendors by total spend in 2021.",
      "target_schema": "div_14",
      "sql_generated": "SELECT v.vendor_number, v.name, SUM(po.total) AS total_spend FROM vendors v JOIN purchase_orders po ON v.vendor_id = po.vendor_id WHERE EXTRACT(YEAR FROM po.order_date) = 2021 GROUP BY v.vendor_number, v.name ORDER BY total_spend DESC LIMIT 5;",
      "gold_sql": "  SELECT v.name, SUM(po.total) AS total_spend\n  FROM div_14.purchase_orders po\n  JOIN div_14.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2021\n  GROUP BY v.name\n  ORDER BY total_spend DESC\n  LIMIT 5;",
      "success": true,
      "latency_ms": 10282,
      "tags": "procurement"
    },
    {
      "qid": "Q0160",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Open opportunities by stage for 2022.",
      "target_schema": "div_18",
      "sql_generated": "SELECT os.stage_id, os.name AS stage_name, COUNT(so.opportunity_id) AS open_opportunities_count FROM sales_opportunities so JOIN opportunity_stages os ON so.stage_id = os.stage_id WHERE EXTRACT(YEAR FROM so.expected_close_date) = 2022 GROUP BY os.stage_id, os.name LIMIT 1000;",
      "gold_sql": "  SELECT os.name, COUNT(*) AS opportunity_count\n  FROM div_18.sales_opportunities so\n  JOIN div_18.opportunity_stages os ON os.stage_id = so.stage_id\n  WHERE EXTRACT(YEAR FROM so.expected_close_date) = 2022\n  GROUP BY os.name;",
      "success": true,
      "latency_ms": 8868,
      "tags": "sales"
    },
    {
      "qid": "Q0161",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "FTE headcount by department for 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT d.department_id, d.name, COUNT(e.employee_id) AS fte_headcount FROM departments d JOIN employees e ON d.department_id = e.department_id AND e.termination_date > '2021-12-31' WHERE e.hire_date < '2022-01-01' AND e.is_active = true GROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name AS department,\n         COUNT(*) AS fte_count\n  FROM div_05.employees e\n  JOIN div_05.departments d ON d.department_id = e.department_id\n  WHERE e.hire_date <= DATE '2021-12-31'\n    AND (e.termination_date IS NULL OR e.termination_date > DATE '2021-01-01')\n  GROUP BY d.name\n  ORDER BY fte_count DESC;",
      "success": true,
      "latency_ms": 12097,
      "tags": "hr,jargon"
    },
    {
      "qid": "Q0162",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_15.",
      "target_schema": "div_15",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS total_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_15.rtl_pos_line_items li\n  JOIN div_15.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 9886,
      "tags": "retail"
    },
    {
      "qid": "Q0163",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average discount percentage on sales order lines in 2022.",
      "target_schema": "div_18",
      "sql_generated": "SELECT AVG(discount_percent) AS avg_discount_percentage FROM order_lines WHERE EXTRACT(YEAR FROM order_date) = 2022 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(ol.discount_percent), 2) AS avg_discount\n  FROM div_18.order_lines ol\n  JOIN div_18.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"order_date\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 4659,
      "tags": "sales"
    },
    {
      "qid": "Q0164",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Billing milestones past due and not yet invoiced for services division div_08.",
      "target_schema": "div_08",
      "sql_generated": "SELECT milestone_id, sow_id, milestone_number, description, amount, due_date FROM svc_billing_milestones WHERE due_date < CURRENT_DATE AND invoice_date IS NULL LIMIT 1000;",
      "gold_sql": "  SELECT sow.sow_number, bm.description, bm.amount, bm.due_date\n  FROM div_08.svc_billing_milestones bm\n  JOIN div_08.svc_statements_of_work sow ON sow.sow_id = bm.sow_id\n  WHERE bm.due_date < CURRENT_DATE AND bm.invoice_date IS NULL\n  ORDER BY bm.due_date;",
      "success": true,
      "latency_ms": 5859,
      "tags": "services"
    },
    {
      "qid": "Q0165",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average discount percentage on sales order lines in 2024.",
      "target_schema": "div_06",
      "sql_generated": "SELECT AVG(discount_percent) AS avg_discount_percentage FROM order_lines WHERE EXTRACT(YEAR FROM order_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(ol.discount_percent), 2) AS avg_discount\n  FROM div_06.order_lines ol\n  JOIN div_06.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"order_date\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 6874,
      "tags": "sales"
    },
    {
      "qid": "Q0166",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inactive vendors.",
      "target_schema": "div_18",
      "sql_generated": "SELECT vendor_id, name, email, phone, website FROM vendors WHERE is_active = false LIMIT 1000;",
      "gold_sql": "  SELECT vendor_id, name\n  FROM div_18.vendors\n  WHERE is_active = FALSE;",
      "success": true,
      "latency_ms": 4401,
      "tags": "procurement"
    },
    {
      "qid": "Q0167",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Period-over-period headcount change by month for 2024.",
      "target_schema": "div_10",
      "sql_generated": "SELECT \n    date_trunc('month', e.hire_date) AS month,\n    COUNT(e.employee_id) AS headcount\nFROM \n    employees e\nWHERE \n    e.termination_date IS NULL AND\n    e.hire_date <= '2024-12-31'\nGROUP BY \n    month\nORDER BY \n    month LIMIT 1000;",
      "gold_sql": "  WITH months AS (\n    SELECT generate_series(1, 12) AS month_num\n  ),\n  headcount AS (\n    SELECT m.month_num,\n           COUNT(*) AS hc\n    FROM months m\n    JOIN div_10.employees e ON e.hire_date <= DATE '2024-12-31'\n      AND (DATE '2024-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date\n      AND (e.termination_date IS NULL\n           OR e.termination_date > DATE '2024-01-01' + (m.month_num - 1) * INTERVAL '1 month')\n    GROUP BY m.month_num\n  )\n  SELECT month_num, hc,\n         hc - LAG(hc) OVER (ORDER BY month_num) AS change\n  FROM headcount\n  ORDER BY month_num;",
      "success": true,
      "latency_ms": 17144,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0168",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Promotion effectiveness: average discount and transaction count per active promotion for div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.promotion_name, AVG(pl.discount_amount) AS avg_discount, COUNT(pl.transaction_id) AS txn_count FROM rtl_pos_line_items pl JOIN rtl_promotions p ON pl.promotion_code = p.promotion_code WHERE p.status_code = 'Active' GROUP BY p.promotion_name LIMIT 1000;",
      "gold_sql": "  SELECT pr.promotion_name, pr.discount_type_code,\n         COUNT(*) AS line_items,\n         ROUND(AVG(li.discount_amount), 2) AS avg_discount\n  FROM div_11.rtl_pos_line_items li\n  JOIN div_11.rtl_promotions pr ON pr.promotion_code = li.promotion_code\n  WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL\n  GROUP BY pr.promotion_name, pr.discount_type_code\n  ORDER BY line_items DESC;",
      "success": true,
      "latency_ms": 10550,
      "tags": "retail"
    },
    {
      "qid": "Q0169",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_03.",
      "target_schema": "div_03",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_03.mfg_work_orders wo\n  JOIN div_03.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 12260,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0170",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Quarterly revenue comparison for 2023.",
      "target_schema": "div_06",
      "sql_generated": "SELECT date_trunc('quarter', o.order_date) AS quarter, SUM(ol.quantity * ol.unit_price) AS revenue FROM sales_orders o JOIN order_lines ol ON o.order_id = ol.order_id WHERE EXTRACT(YEAR FROM o.order_date) = 2023 GROUP BY date_trunc('quarter', o.order_date) ORDER BY quarter LIMIT 1000;",
      "gold_sql": "  SELECT\n    EXTRACT(QUARTER FROM so.order_date) AS quarter,\n    SUM(ol.quantity * ol.unit_price) AS revenue\n  FROM div_06.order_lines ol\n  JOIN div_06.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2023\n  GROUP BY quarter\n  ORDER BY quarter;",
      "success": true,
      "latency_ms": 13084,
      "tags": "sales,temporal"
    },
    {
      "qid": "Q0171",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inventory lots expiring within 60 days.",
      "target_schema": "div_11",
      "sql_generated": "SELECT lot_id, product_id, warehouse_id, lot_number, received_date, expiration_date, quantity FROM inventory_lots WHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' LIMIT 1000;",
      "gold_sql": "  SELECT lot_id, lot_number, expiration_date\n  FROM div_11.inventory_lots\n  WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';",
      "success": true,
      "latency_ms": 6724,
      "tags": "inventory"
    },
    {
      "qid": "Q0172",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top expense categories for 2023.",
      "target_schema": "div_18",
      "sql_generated": "SELECT category, SUM(amount) AS total_amount FROM project_expenses WHERE EXTRACT(YEAR FROM expense_date) = 2023 GROUP BY category ORDER BY total_amount DESC LIMIT 1000;",
      "gold_sql": "  SELECT category, SUM(amount) AS total\n  FROM div_18.project_expenses\n  WHERE EXTRACT(YEAR FROM expense_date) = 2023\n  GROUP BY category\n  ORDER BY total DESC;",
      "success": true,
      "latency_ms": 6137,
      "tags": "projects"
    },
    {
      "qid": "Q0173",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_11",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_11.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 2556,
      "tags": "support"
    },
    {
      "qid": "Q0174",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Weighted average cost per unit by product for 2021.",
      "target_schema": "div_03",
      "sql_generated": "SELECT p.product_id, p.sku, p.name, SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0) AS weighted_avg_cost_per_unit \nFROM order_lines ol \nJOIN products p ON ol.product_id = p.product_id \nWHERE EXTRACT(YEAR FROM ol.order_date) = 2021 \nGROUP BY p.product_id, p.sku, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         ROUND(SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0), 2) AS weighted_avg_cost,\n         SUM(ol.quantity) AS total_units\n  FROM div_03.order_lines ol\n  JOIN div_03.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_03.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY p.name\n  ORDER BY weighted_avg_cost DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 18053,
      "tags": "finance,jargon"
    },
    {
      "qid": "Q0175",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Promotion effectiveness: average discount and transaction count per active promotion for div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.promotion_name, AVG(pl.discount_amount) AS avg_discount, COUNT(pl.transaction_id) AS txn_count FROM rtl_pos_line_items pl JOIN rtl_promotions p ON pl.promotion_code = p.promotion_code WHERE p.status_code = 'Active' GROUP BY p.promotion_name LIMIT 1000;",
      "gold_sql": "  SELECT pr.promotion_name, pr.discount_type_code,\n         COUNT(*) AS line_items,\n         ROUND(AVG(li.discount_amount), 2) AS avg_discount\n  FROM div_11.rtl_pos_line_items li\n  JOIN div_11.rtl_promotions pr ON pr.promotion_code = li.promotion_code\n  WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL\n  GROUP BY pr.promotion_name, pr.discount_type_code\n  ORDER BY line_items DESC;",
      "success": true,
      "latency_ms": 10098,
      "tags": "retail"
    },
    {
      "qid": "Q0176",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Quarterly revenue comparison for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT date_trunc('quarter', o.order_date) AS quarter, SUM(ol.quantity * ol.unit_price) AS total_revenue FROM sales_orders o JOIN order_lines ol ON o.order_id = ol.order_id WHERE EXTRACT(YEAR FROM o.order_date) = 2024 GROUP BY date_trunc('quarter', o.order_date) ORDER BY quarter LIMIT 1000;",
      "gold_sql": "  SELECT\n    EXTRACT(QUARTER FROM so.order_date) AS quarter,\n    SUM(ol.quantity * ol.unit_price) AS revenue\n  FROM div_12.order_lines ol\n  JOIN div_12.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY quarter\n  ORDER BY quarter;",
      "success": true,
      "latency_ms": 10775,
      "tags": "sales,temporal"
    },
    {
      "qid": "Q0177",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_04.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(w.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders w\nJOIN \n    lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_04.xx_mfg_wo wo\n  JOIN div_04.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 14153,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0178",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Working capital ratio: current assets (AR) vs current liabilities (AP) for 2023.",
      "target_schema": "div_17",
      "sql_generated": "SELECT SUM(ar.amount) AS ar_open_amount, SUM(ap.amount) AS ap_open_amount, (SUM(ar.amount) * 100.0 / NULLIF(SUM(ap.amount), 0)) AS working_capital_ratio FROM finance_ar_invoices ar JOIN finance_ap_invoices ap ON ar.customer_id = ap.vendor_id WHERE EXTRACT(YEAR FROM ar.invoice_date) = 2023 AND EXTRACT(YEAR FROM ap.invoice_date) = 2023 LIMIT 1000;",
      "gold_sql": "  WITH ar AS (\n    SELECT SUM(amount) AS total_ar\n    FROM div_17.finance_ar_invoices\n    WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = 2023\n  ),\n  ap AS (\n    SELECT SUM(amount) AS total_ap\n    FROM div_17.finance_ap_invoices\n    WHERE status = 'open' AND EXTRACT(YEAR FROM invoice_date) = 2023\n  )\n  SELECT ar.total_ar, ap.total_ap,\n         ROUND(ar.total_ar / NULLIF(ap.total_ap, 0), 2) AS working_capital_ratio\n  FROM ar, ap;",
      "success": true,
      "latency_ms": 13385,
      "tags": "finance,jargon"
    },
    {
      "qid": "Q0179",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales orders shipped after ship_date in 2023.",
      "target_schema": "div_12",
      "sql_generated": "SELECT * FROM sales_orders WHERE ship_date > '2023-01-01' AND ship_date < '2024-01-01' LIMIT 1000;",
      "gold_sql": "  SELECT order_id, customer_id, order_date, ship_date\n  FROM div_12.sales_orders\n  WHERE ship_date IS NOT NULL\n    AND ship_date > order_date\n    AND EXTRACT(YEAR FROM order_date) = 2023;",
      "success": true,
      "latency_ms": 5903,
      "tags": "sales"
    },
    {
      "qid": "Q0180",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2023.",
      "target_schema": "div_17",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2023-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_17.journal_lines jl\n  JOIN div_17.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_17.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2023\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 11289,
      "tags": "finance"
    },
    {
      "qid": "Q0181",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Revenue per FTE by department for 2021.",
      "target_schema": "div_20",
      "sql_generated": "SELECT d.department_id, d.name AS department_name, COUNT(e.employee_id) AS fte_count, SUM(s.total) AS revenue FROM departments d JOIN employees e ON d.department_id = e.department_id JOIN sales_orders s ON e.employee_id = s.sales_rep_id WHERE EXTRACT(YEAR FROM s.order_date) = 2021 GROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  WITH dept_revenue AS (\n    SELECT e.department_id,\n           SUM(ol.quantity * ol.unit_price) AS revenue\n    FROM div_20.order_lines ol\n    JOIN div_20.sales_orders so ON so.order_id = ol.order_id\n    JOIN div_20.employees e ON e.employee_id = so.sales_rep_id\n    WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n    GROUP BY e.department_id\n  ),\n  dept_fte AS (\n    SELECT department_id, COUNT(*) AS fte\n    FROM div_20.employees\n    WHERE hire_date <= DATE '2021-12-31'\n      AND (termination_date IS NULL OR termination_date > DATE '2021-01-01')\n    GROUP BY department_id\n  )\n  SELECT d.name,\n         dr.revenue,\n         df.fte,\n         ROUND(dr.revenue / NULLIF(df.fte, 0), 2) AS revenue_per_fte\n  FROM dept_revenue dr\n  JOIN dept_fte df ON df.department_id = dr.department_id\n  JOIN div_20.departments d ON d.department_id = dr.department_id\n  ORDER BY revenue_per_fte DESC;",
      "success": true,
      "latency_ms": 12053,
      "tags": "sales,hr,jargon"
    },
    {
      "qid": "Q0182",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Training completion rate by course for 2021.",
      "target_schema": "div_09",
      "sql_generated": "SELECT tc.course_id, tc.name AS course_name, COUNT(et.employee_id) AS completed_count, COUNT(*) AS total_enrolled, ROUND(COUNT(et.employee_id) * 100.0 / NULLIF(COUNT(*), 0), 2) AS completion_rate FROM employee_training et JOIN training_courses tc ON et.course_id = tc.course_id WHERE EXTRACT(YEAR FROM et.completion_date) = 2021 GROUP BY tc.course_id, tc.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, COUNT(*) AS completions\n  FROM div_09.employee_training et\n  JOIN div_09.training_courses c ON c.course_id = et.course_id\n  WHERE EXTRACT(YEAR FROM et.completion_date) = 2021\n  GROUP BY c.name\n  ORDER BY completions DESC;",
      "success": true,
      "latency_ms": 15913,
      "tags": "hr,training"
    },
    {
      "qid": "Q0183",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT pc.name AS category_name, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS inventory_turns FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN inventory_transactions it ON p.product_id = it.product_id WHERE it.transaction_date BETWEEN '2024-01-01' AND '2024-12-31' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_12.inventory_transactions it\n  JOIN div_12.products p ON p.product_id = it.product_id\n  JOIN div_12.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2024\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 10892,
      "tags": "inventory"
    },
    {
      "qid": "Q0184",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Count inventory adjustments by reason in 2024.",
      "target_schema": "div_09",
      "sql_generated": "SELECT reason, COUNT(*) AS adjustment_count FROM inventory_adjustments WHERE EXTRACT(YEAR FROM adjustment_date) = 2024 GROUP BY reason LIMIT 1000;",
      "gold_sql": "  SELECT reason, COUNT(*) AS adjustment_count\n  FROM div_09.inventory_adjustments\n  WHERE EXTRACT(YEAR FROM adjustment_date) = 2024\n  GROUP BY reason;",
      "success": true,
      "latency_ms": 5594,
      "tags": "inventory"
    },
    {
      "qid": "Q0185",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_12.",
      "target_schema": "div_12",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_12.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6700,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0186",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Cost of goods sold by product line for 2022.",
      "target_schema": "div_04",
      "sql_generated": "SELECT p.product_id, p.name AS product_name, SUM(ol.quantity) * p.list_price * (p.unit_cost / p.list_price) AS cogs FROM sales_orders so JOIN order_lines ol ON so.order_id = ol.order_id JOIN products p ON ol.product_id = p.product_id WHERE EXTRACT(YEAR FROM so.order_date) = 2022 GROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name AS product_line,\n         SUM(ol.quantity * ol.unit_price) AS total_revenue,\n         COUNT(DISTINCT so.order_id) AS order_count\n  FROM div_04.order_lines ol\n  JOIN div_04.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_04.products p ON p.product_id = ol.product_id\n  JOIN div_04.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY pc.name\n  ORDER BY total_revenue DESC;",
      "success": true,
      "latency_ms": 13539,
      "tags": "finance,kpi"
    },
    {
      "qid": "Q0187",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Complete employee profile: department, position, salary, benefits, certifications for 2021.",
      "target_schema": "div_02",
      "sql_generated": "SELECT d.name AS department, p.title AS position, s.amount AS salary, b.benefit_type_id, b.coverage_level, c.certification_id, c.expiry_date FROM employees e JOIN departments d ON e.department_id = d.department_id JOIN positions p ON e.position_id = p.position_id JOIN employee_salaries s ON e.employee_id = s.employee_id AND s.effective_date <= '2021-12-31' AND (s.end_date IS NULL OR s.end_date >= '2021-01-01') LEFT JOIN hr_benefit_elections b ON e.employee_id = b.employee_id LEFT JOIN employee_certifications c ON e.employee_id = c.employee_id LIMIT 1000;",
      "gold_sql": "  SELECT e.first_name, e.last_name,\n         d.name AS department,\n         pos.title AS position,\n         es.amount AS salary,\n         COUNT(DISTINCT be.election_id) AS benefit_elections,\n         COUNT(DISTINCT ec.certification_id) AS certifications\n  FROM div_02.employees e\n  JOIN div_02.departments d ON d.department_id = e.department_id\n  LEFT JOIN div_02.positions pos ON pos.position_id = e.position_id\n  LEFT JOIN div_02.employee_salaries es ON es.employee_id = e.employee_id\n    AND es.effective_date <= DATE '2021-12-31'\n  LEFT JOIN div_02.hr_benefit_elections be ON be.employee_id = e.employee_id\n    AND EXTRACT(YEAR FROM be.election_date) = 2021\n  LEFT JOIN div_02.employee_certifications ec ON ec.employee_id = e.employee_id\n  GROUP BY e.first_name, e.last_name, d.name, pos.title, es.amount\n  LIMIT 50;",
      "success": true,
      "latency_ms": 21389,
      "tags": "hr,multi_join"
    },
    {
      "qid": "Q0188",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List bank accounts with balance under 500.",
      "target_schema": "div_05",
      "sql_generated": "SELECT account_number, account_name, current_balance FROM bank_accounts WHERE current_balance < 500 LIMIT 1000;",
      "gold_sql": "  SELECT bank_account_id, account_number, bank_name, current_balance\n  FROM div_05.bank_accounts\n  WHERE current_balance < 500;",
      "success": true,
      "latency_ms": 3672,
      "tags": "finance"
    },
    {
      "qid": "Q0189",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from RFQ to vendor response for 2021.",
      "target_schema": "div_12",
      "sql_generated": "SELECT AVG(response_date - rfq_date) AS avg_days_to_response FROM procurement_rfqs rfqs JOIN procurement_rfq_responses responses ON rfqs.rfq_id = responses.rfq_id WHERE EXTRACT(YEAR FROM response_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(r.response_date - q.rfq_date), 2) AS avg_days\n  FROM div_12.procurement_rfqs q\n  JOIN div_12.procurement_rfq_responses r ON r.rfq_id = q.rfq_id\n  WHERE EXTRACT(YEAR FROM q.rfq_date) = 2021;",
      "success": true,
      "latency_ms": 9151,
      "tags": "procurement,time"
    },
    {
      "qid": "Q0190",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 5262,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0191",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average days between vendor invoice date and due date by vendor.",
      "target_schema": "div_18",
      "sql_generated": "SELECT vendor_id, AVG(due_date - invoice_date) AS avg_days_between_due_and_invoice FROM vendor_invoices GROUP BY vendor_id LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(vi.due_date - vi.invoice_date)::numeric, 2) AS avg_days\n  FROM div_18.vendor_invoices vi\n  JOIN div_18.vendors v ON v.vendor_id = vi.vendor_id\n  GROUP BY v.name\n  ORDER BY avg_days DESC;",
      "success": true,
      "latency_ms": 7388,
      "tags": "procurement"
    },
    {
      "qid": "Q0192",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "QC failure rate for inventory lots in 2023.",
      "target_schema": "div_12",
      "sql_generated": "SELECT lot_id, COUNT(*) FILTER (WHERE result = 'fail') AS fail_count, COUNT(*) AS total_count, (COUNT(*) FILTER (WHERE result = 'fail') * 100.0 / NULLIF(COUNT(*), 0)) AS failure_rate FROM inventory_qc_inspections WHERE inspection_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY lot_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN qi.result = 'fail' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_pct\n  FROM div_12.inventory_qc_inspections qi\n  WHERE EXTRACT(YEAR FROM qi.inspection_date) = 2023;",
      "success": true,
      "latency_ms": 15171,
      "tags": "inventory,qc"
    },
    {
      "qid": "Q0193",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nWHERE s.division = 'div_06' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_06.svc_statements_of_work sow\n  JOIN div_06.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column s.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 11348,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0194",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Open opportunities by stage for 2023.",
      "target_schema": "div_02",
      "sql_generated": "SELECT os.stage_id, os.name, COUNT(so.opportunity_id) AS open_opportunities FROM sales_opportunities so JOIN opportunity_stages os ON so.stage_id = os.stage_id WHERE EXTRACT(YEAR FROM so.expected_close_date) = 2023 AND os.is_closed = FALSE GROUP BY os.stage_id, os.name LIMIT 1000;",
      "gold_sql": "  SELECT os.name, COUNT(*) AS opportunity_count\n  FROM div_02.sales_opportunities so\n  JOIN div_02.opportunity_stages os ON os.stage_id = so.stage_id\n  WHERE EXTRACT(YEAR FROM so.expected_close_date) = 2023\n  GROUP BY os.name;",
      "success": true,
      "latency_ms": 11249,
      "tags": "sales"
    },
    {
      "qid": "Q0195",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2024.",
      "target_schema": "div_16",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2024-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_16.journal_lines jl\n  JOIN div_16.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_16.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2024\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 9365,
      "tags": "finance"
    },
    {
      "qid": "Q0196",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_02.",
      "target_schema": "div_02",
      "sql_generated": "SELECT l.meaning AS status_description, COUNT(w.wo_id) AS work_order_count FROM xx_mfg_wo w JOIN lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS' GROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_02.xx_mfg_wo wo\n  JOIN div_02.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": true,
      "latency_ms": 9401,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0197",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total scrap quantity by reason for manufacturing division div_05.",
      "target_schema": "div_05",
      "sql_generated": "SELECT reason_code, SUM(scrap_quantity) AS total_scrap_quantity \nFROM mfg_scrap_log \nWHERE work_order_id IN (SELECT work_order_id FROM mfg_work_orders WHERE department_id = 'div_05') \nGROUP BY reason_code LIMIT 1000;",
      "gold_sql": "  SELECT reason_code, SUM(scrap_quantity) AS total_scrap\n  FROM div_05.mfg_scrap_log\n  GROUP BY reason_code\n  ORDER BY total_scrap DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"department_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 12518,
      "tags": "manufacturing"
    },
    {
      "qid": "Q0198",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_08.",
      "target_schema": "div_08",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nWHERE s.division = 'div_08' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_08.svc_statements_of_work sow\n  JOIN div_08.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column s.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 11359,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0199",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee utilization rate = hours logged / 40 by week in 2021.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    timesheets.week_start_date AS week,\n    SUM(timesheet_entries.hours) / 40.0 AS utilization_rate\nFROM \n    timesheet_entries\nJOIN \n    timesheets ON timesheet_entries.timesheet_id = timesheets.timesheet_id\nWHERE \n    EXTRACT(YEAR FROM timesheets.week_start_date) = 2021\nGROUP BY \n    timesheets.week_start_date LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, DATE_TRUNC('week', t.week_start_date) AS week_start,\n         ROUND(SUM(te.hours) / 40.0, 2) AS utilization\n  FROM div_04.timesheets t\n  JOIN div_04.timesheet_entries te ON te.timesheet_id = t.timesheet_id\n  JOIN div_04.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.week_start_date) = 2021\n  GROUP BY e.employee_id, week_start;",
      "success": true,
      "latency_ms": 15154,
      "tags": "projects,hr"
    },
    {
      "qid": "Q0200",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Budget variance (planned vs actual) by department for 2023.",
      "target_schema": "div_01",
      "sql_generated": "SELECT \n    b.department_id,\n    SUM(pb.planned_amount) AS planned_amount,\n    SUM(pe.amount) AS actual_amount,\n    (SUM(pe.amount) - SUM(pb.planned_amount)) AS variance\nFROM \n    budgets b\nJOIN \n    project_budgets pb ON b.budget_id = pb.budget_id\nJOIN \n    project_expenses pe ON pb.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2023\nGROUP BY \n    b.department_id LIMIT 1000;",
      "gold_sql": "  SELECT d.name,\n         b.total_amount AS planned,\n         COALESCE(SUM(pe.amount), 0) AS actual,\n         b.total_amount - COALESCE(SUM(pe.amount), 0) AS variance\n  FROM div_01.budgets b\n  JOIN div_01.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_01.project_expenses pe ON pe.project_id IN (\n    SELECT project_id FROM div_01.projects WHERE customer_id IS NOT NULL\n  ) AND EXTRACT(YEAR FROM pe.expense_date) = 2023\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2023\n  GROUP BY d.name, b.total_amount\n  ORDER BY variance;",
      "success": true,
      "latency_ms": 19820,
      "tags": "finance,budget"
    },
    {
      "qid": "Q0201",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total scrap quantity by reason for manufacturing division div_05.",
      "target_schema": "div_05",
      "sql_generated": "SELECT reason_code, SUM(scrap_quantity) AS total_scrap_quantity \nFROM mfg_scrap_log \nWHERE work_order_id IN (SELECT work_order_id FROM mfg_work_orders WHERE department_id = 'div_05') \nGROUP BY reason_code LIMIT 1000;",
      "gold_sql": "  SELECT reason_code, SUM(scrap_quantity) AS total_scrap\n  FROM div_05.mfg_scrap_log\n  GROUP BY reason_code\n  ORDER BY total_scrap DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"department_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 12548,
      "tags": "manufacturing"
    },
    {
      "qid": "Q0202",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Gross margin (revenue - COGS estimate) by product for 2022.",
      "target_schema": "div_09",
      "sql_generated": "SELECT p.product_id, p.name, SUM(ol.quantity * ol.unit_price) AS revenue, SUM(ol.quantity * p.list_price * 0.6) AS cogs_estimate, (SUM(ol.quantity * ol.unit_price) - SUM(ol.quantity * p.list_price * 0.6)) / NULLIF(SUM(ol.quantity * p.list_price * 0.6), 0) * 100 AS gross_margin_pct \nFROM order_lines ol \nJOIN products p ON ol.product_id = p.product_id \nWHERE ol.order_date >= '2022-01-01' AND ol.order_date < '2023-01-01' \nGROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         SUM(ol.quantity * ol.unit_price) AS revenue,\n         SUM(ol.quantity * ol.unit_price * 0.6) AS estimated_cogs,\n         ROUND(SUM(ol.quantity * ol.unit_price * 0.4), 2) AS gross_margin\n  FROM div_09.order_lines ol\n  JOIN div_09.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_09.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY p.name\n  ORDER BY gross_margin DESC\n  LIMIT 20;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 24507,
      "tags": "sales,finance,kpi"
    },
    {
      "qid": "Q0203",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_04.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(w.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders w\nJOIN \n    lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_04.xx_mfg_wo wo\n  JOIN div_04.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 13717,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0204",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Period-over-period headcount change by month for 2022.",
      "target_schema": "div_05",
      "sql_generated": "SELECT date_trunc('month', e.hire_date) AS month, COUNT(e.employee_id) AS headcount FROM employees e WHERE e.termination_date IS NULL AND e.hire_date <= '2022-12-31' GROUP BY month ORDER BY month LIMIT 1000;",
      "gold_sql": "  WITH months AS (\n    SELECT generate_series(1, 12) AS month_num\n  ),\n  headcount AS (\n    SELECT m.month_num,\n           COUNT(*) AS hc\n    FROM months m\n    JOIN div_05.employees e ON e.hire_date <= DATE '2022-12-31'\n      AND (DATE '2022-01-01' + (m.month_num - 1) * INTERVAL '1 month') >= e.hire_date\n      AND (e.termination_date IS NULL\n           OR e.termination_date > DATE '2022-01-01' + (m.month_num - 1) * INTERVAL '1 month')\n    GROUP BY m.month_num\n  )\n  SELECT month_num, hc,\n         hc - LAG(hc) OVER (ORDER BY month_num) AS change\n  FROM headcount\n  ORDER BY month_num;",
      "success": true,
      "latency_ms": 14379,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0205",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2021.",
      "target_schema": "div_20",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2021-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_20.journal_lines jl\n  JOIN div_20.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_20.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2021\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 12004,
      "tags": "finance"
    },
    {
      "qid": "Q0206",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Aged AR receivables buckets (0-30, 31-60, 61-90, 90+) for 2023.",
      "target_schema": "div_20",
      "sql_generated": "SELECT \n    CASE \n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '0 days' AND INTERVAL '30 days' THEN '0-30'\n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '31 days' AND INTERVAL '60 days' THEN '31-60'\n        WHEN (CURRENT_DATE - invoice_date) BETWEEN INTERVAL '61 days' AND INTERVAL '90 days' THEN '61-90'\n        ELSE '90+'\n    END AS age_bucket, \n    COUNT(*) AS count \nFROM \n    finance_ar_invoices \nWHERE \n    status = 'open' \n    AND EXTRACT(YEAR FROM invoice_date) = 2023 \nGROUP BY \n    age_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN CURRENT_DATE - due_date <= 30 THEN '0-30'\n      WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'\n      WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'\n      ELSE '90+'\n    END AS aging_bucket,\n    COUNT(*) AS invoice_count,\n    SUM(amount) AS total_amount\n  FROM div_20.finance_ar_invoices\n  WHERE status = 'open'\n    AND EXTRACT(YEAR FROM invoice_date) = 2023\n  GROUP BY aging_bucket\n  ORDER BY aging_bucket;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: operator does not exist: integer >= interval",
      "sqlstate": "42883",
      "latency_ms": 26040,
      "tags": "finance,ar,aging"
    },
    {
      "qid": "Q0207",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Procure-to-pay cycle: PO to receipt to invoice for each vendor in 2021.",
      "target_schema": "div_10",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, p.po_number, gr.receipt_number, vi.invoice_number, p.order_date, gr.receipt_date, vi.invoice_date FROM purchase_orders p JOIN goods_receipts gr ON p.po_id = gr.po_id JOIN vendor_invoices vi ON gr.receipt_id = vi.po_id JOIN vendors v ON vi.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM p.order_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT v.name AS vendor,\n         po.po_id,\n         po.order_date,\n         gr.receipt_id,\n         gr.receipt_date,\n         vi.invoice_id,\n         vi.invoice_date,\n         vi.total AS invoice_total\n  FROM div_10.purchase_orders po\n  JOIN div_10.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_10.vendor_invoices vi ON vi.po_id = po.po_id\n  JOIN div_10.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2021\n  ORDER BY po.order_date\n  LIMIT 50;",
      "success": true,
      "latency_ms": 16000,
      "tags": "procurement,multi_join"
    },
    {
      "qid": "Q0208",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total AP invoice amount by vendor for 2024.",
      "target_schema": "div_17",
      "sql_generated": "SELECT v.vendor_id, v.name, SUM(fai.amount) AS total_ap_invoice_amount FROM finance_ap_invoices fai JOIN vendors v ON fai.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM fai.invoice_date) = 2024 GROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name, SUM(ai.amount) AS total_amount\n  FROM div_17.finance_ap_invoices ai\n  JOIN div_17.vendors v ON v.vendor_id = ai.vendor_id\n  WHERE EXTRACT(YEAR FROM ai.invoice_date) = 2024\n  GROUP BY v.name\n  ORDER BY total_amount DESC;",
      "success": true,
      "latency_ms": 9611,
      "tags": "finance,ap"
    },
    {
      "qid": "Q0209",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total maintenance cost by asset category in 2022.",
      "target_schema": "div_03",
      "sql_generated": "SELECT ac.name AS category_name, SUM(am.cost) AS total_cost FROM asset_maintenance am JOIN fixed_assets fa ON am.asset_id = fa.asset_id JOIN asset_categories ac ON fa.category_id = ac.category_id WHERE date_trunc('year', am.scheduled_date) = '2022-01-01' GROUP BY ac.name LIMIT 1000;",
      "gold_sql": "  SELECT ac.name, SUM(am.cost) AS total_cost\n  FROM div_03.asset_maintenance am\n  JOIN div_03.fixed_assets fa ON fa.asset_id = am.asset_id\n  JOIN div_03.asset_categories ac ON ac.category_id = fa.category_id\n  WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2022\n  GROUP BY ac.name;",
      "success": true,
      "latency_ms": 10372,
      "tags": "assets"
    },
    {
      "qid": "Q0210",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_01.",
      "target_schema": "div_01",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_01.mfg_work_orders wo\n  JOIN div_01.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 13152,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0211",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top expense categories for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT category, SUM(amount) AS total_amount FROM project_expenses WHERE EXTRACT(YEAR FROM expense_date) = 2024 GROUP BY category ORDER BY total_amount DESC LIMIT 1000;",
      "gold_sql": "  SELECT category, SUM(amount) AS total\n  FROM div_12.project_expenses\n  WHERE EXTRACT(YEAR FROM expense_date) = 2024\n  GROUP BY category\n  ORDER BY total DESC;",
      "success": true,
      "latency_ms": 6301,
      "tags": "projects"
    },
    {
      "qid": "Q0212",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Billing milestones past due and not yet invoiced for services division div_08.",
      "target_schema": "div_08",
      "sql_generated": "SELECT milestone_id, sow_id, milestone_number, description, amount, due_date FROM svc_billing_milestones WHERE due_date < CURRENT_DATE AND invoice_date IS NULL LIMIT 1000;",
      "gold_sql": "  SELECT sow.sow_number, bm.description, bm.amount, bm.due_date\n  FROM div_08.svc_billing_milestones bm\n  JOIN div_08.svc_statements_of_work sow ON sow.sow_id = bm.sow_id\n  WHERE bm.due_date < CURRENT_DATE AND bm.invoice_date IS NULL\n  ORDER BY bm.due_date;",
      "success": true,
      "latency_ms": 5906,
      "tags": "services"
    },
    {
      "qid": "Q0213",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2022.",
      "target_schema": "div_14",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2022-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_14.journal_lines jl\n  JOIN div_14.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_14.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2022\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 9364,
      "tags": "finance"
    },
    {
      "qid": "Q0214",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_04.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(w.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders w\nJOIN \n    lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_04.xx_mfg_wo wo\n  JOIN div_04.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 14098,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0215",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Net intercompany balance between divisions for corporate division div_16.",
      "target_schema": "div_16",
      "sql_generated": "SELECT from_division, to_division, SUM(CASE WHEN from_division = 'div_16' THEN amount ELSE 0 END) AS sent, SUM(CASE WHEN to_division = 'div_16' THEN amount ELSE 0 END) AS received, (SUM(CASE WHEN from_division = 'div_16' THEN amount ELSE 0 END) - SUM(CASE WHEN to_division = 'div_16' THEN amount ELSE 0 END)) AS net_balance FROM corp_intercompany_txns GROUP BY from_division, to_division LIMIT 1000;",
      "gold_sql": "  SELECT from_division, to_division,\n         SUM(amount) AS total_transferred,\n         COUNT(*) AS txn_count\n  FROM div_16.corp_intercompany_txns\n  WHERE status_code = 'AP'\n  GROUP BY from_division, to_division\n  ORDER BY total_transferred DESC;",
      "success": true,
      "latency_ms": 17374,
      "tags": "corporate"
    },
    {
      "qid": "Q0216",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_08",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_08.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 4562,
      "tags": "support"
    },
    {
      "qid": "Q0217",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average days between vendor invoice date and due date by vendor.",
      "target_schema": "div_05",
      "sql_generated": "SELECT vendor_id, AVG(due_date - invoice_date) AS avg_days_between_due_and_invoice FROM vendor_invoices GROUP BY vendor_id LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(vi.due_date - vi.invoice_date)::numeric, 2) AS avg_days\n  FROM div_05.vendor_invoices vi\n  JOIN div_05.vendors v ON v.vendor_id = vi.vendor_id\n  GROUP BY v.name\n  ORDER BY avg_days DESC;",
      "success": true,
      "latency_ms": 7378,
      "tags": "procurement"
    },
    {
      "qid": "Q0218",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_04.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(w.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders w\nJOIN \n    lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_04.xx_mfg_wo wo\n  JOIN div_04.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 13650,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0219",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total employee cost (gross pay) per department for 2023.",
      "target_schema": "div_09",
      "sql_generated": "SELECT d.name AS department_name, SUM(prl.gross_pay) AS total_employee_cost \nFROM departments d \nJOIN employees e ON d.department_id = e.department_id \nJOIN payroll_run_line prl ON e.employee_id = prl.employee_id \nWHERE prl.pay_period_start >= '2023-01-01' AND prl.pay_period_end <= '2023-12-31' \nGROUP BY d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name,\n         SUM(prl.gross_pay) AS total_cost,\n         COUNT(DISTINCT prl.employee_id) AS employee_count\n  FROM div_09.payroll_run_line prl\n  JOIN div_09.payroll_run_hdr prh ON prh.run_id = prl.run_id\n  JOIN div_09.employees e ON e.employee_id = prl.employee_id\n  JOIN div_09.departments d ON d.department_id = e.department_id\n  WHERE EXTRACT(YEAR FROM prh.pay_period_start) = 2023\n  GROUP BY d.name\n  ORDER BY total_cost DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column prl.pay_period_start does not exist",
      "sqlstate": "42703",
      "latency_ms": 14687,
      "tags": "hr,finance"
    },
    {
      "qid": "Q0220",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_01.",
      "target_schema": "div_01",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_01.mfg_work_orders wo\n  JOIN div_01.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 15190,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0221",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Weighted average cost per unit by product for 2021.",
      "target_schema": "div_19",
      "sql_generated": "SELECT p.product_id, p.sku, p.name, SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0) AS weighted_avg_cost_per_unit \nFROM order_lines ol \nJOIN products p ON ol.product_id = p.product_id \nWHERE EXTRACT(YEAR FROM ol.order_date::date) = 2021 \nGROUP BY p.product_id, p.sku, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         ROUND(SUM(ol.quantity * ol.unit_price) / NULLIF(SUM(ol.quantity), 0), 2) AS weighted_avg_cost,\n         SUM(ol.quantity) AS total_units\n  FROM div_19.order_lines ol\n  JOIN div_19.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_19.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2021\n  GROUP BY p.name\n  ORDER BY weighted_avg_cost DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 15958,
      "tags": "finance,jargon"
    },
    {
      "qid": "Q0222",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Workflow approval counts by decoded approval status.",
      "target_schema": "div_10",
      "sql_generated": "",
      "gold_sql": "  SELECT status, COUNT(*) AS step_count\n  FROM div_10.wf_approval_step\n  GROUP BY status\n  ORDER BY step_count DESC;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 8622,
      "tags": "workflow,lookup"
    },
    {
      "qid": "Q0223",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Gross margin (revenue - COGS estimate) by product for 2022.",
      "target_schema": "div_08",
      "sql_generated": "SELECT p.product_id, p.name, SUM(ol.quantity * ol.unit_price) AS revenue, SUM(ol.quantity * p.list_price * 0.6) AS cogs_estimate, (SUM(ol.quantity * ol.unit_price) - SUM(ol.quantity * p.list_price * 0.6)) / NULLIF(SUM(ol.quantity * p.list_price * 0.6), 0) * 100 AS gross_margin_pct \nFROM order_lines ol \nJOIN products p ON ol.product_id = p.product_id \nWHERE ol.order_date >= '2022-01-01' AND ol.order_date < '2023-01-01' \nGROUP BY p.product_id, p.name LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         SUM(ol.quantity * ol.unit_price) AS revenue,\n         SUM(ol.quantity * ol.unit_price * 0.6) AS estimated_cogs,\n         ROUND(SUM(ol.quantity * ol.unit_price * 0.4), 2) AS gross_margin\n  FROM div_08.order_lines ol\n  JOIN div_08.sales_orders so ON so.order_id = ol.order_id\n  JOIN div_08.products p ON p.product_id = ol.product_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY p.name\n  ORDER BY gross_margin DESC\n  LIMIT 20;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ol.order_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 25209,
      "tags": "sales,finance,kpi"
    },
    {
      "qid": "Q0224",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Net intercompany balance between divisions for corporate division div_19.",
      "target_schema": "div_19",
      "sql_generated": "SELECT from_division, to_division, SUM(CASE WHEN from_division = 'div_19' THEN amount ELSE 0 END) AS sent, SUM(CASE WHEN to_division = 'div_19' THEN amount ELSE 0 END) AS received, (SUM(CASE WHEN from_division = 'div_19' THEN amount ELSE 0 END) - SUM(CASE WHEN to_division = 'div_19' THEN amount ELSE 0 END)) AS net_balance FROM corp_intercompany_txns WHERE from_division IN ('div_19', 'other_division') OR to_division IN ('div_19', 'other_division') GROUP BY from_division, to_division LIMIT 1000;",
      "gold_sql": "  SELECT from_division, to_division,\n         SUM(amount) AS total_transferred,\n         COUNT(*) AS txn_count\n  FROM div_19.corp_intercompany_txns\n  WHERE status_code = 'AP'\n  GROUP BY from_division, to_division\n  ORDER BY total_transferred DESC;",
      "success": true,
      "latency_ms": 17724,
      "tags": "corporate"
    },
    {
      "qid": "Q0225",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Promotion effectiveness: average discount and transaction count per active promotion for div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.promotion_name, AVG(pl.discount_amount) AS avg_discount, COUNT(pl.transaction_id) AS txn_count FROM rtl_pos_line_items pl JOIN rtl_promotions p ON pl.promotion_code = p.promotion_code WHERE p.status_code = 'Active' GROUP BY p.promotion_name LIMIT 1000;",
      "gold_sql": "  SELECT pr.promotion_name, pr.discount_type_code,\n         COUNT(*) AS line_items,\n         ROUND(AVG(li.discount_amount), 2) AS avg_discount\n  FROM div_11.rtl_pos_line_items li\n  JOIN div_11.rtl_promotions pr ON pr.promotion_code = li.promotion_code\n  WHERE pr.status_code = 'AC' AND li.promotion_code IS NOT NULL\n  GROUP BY pr.promotion_name, pr.discount_type_code\n  ORDER BY line_items DESC;",
      "success": true,
      "latency_ms": 10551,
      "tags": "retail"
    },
    {
      "qid": "Q0226",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Compare effective vs statutory tax rate by jurisdiction for corporate division div_19.",
      "target_schema": "div_19",
      "sql_generated": "SELECT t.jurisdiction, t.effective_rate, t.statutory_rate, (t.effective_rate - t.statutory_rate) * 100.0 / NULLIF(t.statutory_rate, 0) AS rate_difference_pct FROM corp_tax_provisions t WHERE t.division = 'div_19' LIMIT 1000;",
      "gold_sql": "  SELECT jurisdiction, tax_type,\n         ROUND(AVG(effective_rate), 4) AS avg_effective_rate,\n         ROUND(AVG(statutory_rate), 4) AS avg_statutory_rate,\n         ROUND(AVG(statutory_rate - effective_rate), 4) AS avg_rate_gap,\n         SUM(current_provision + deferred_provision) AS total_provision\n  FROM div_19.corp_tax_provisions\n  GROUP BY jurisdiction, tax_type\n  ORDER BY total_provision DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column t.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 13605,
      "tags": "corporate"
    },
    {
      "qid": "Q0227",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Project profitability: budget vs actual with milestones and timesheets for 2021.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.project_id, p.name AS project_name, pb.planned_amount, SUM(pe.amount) AS actual_expenses, SUM(te.hours * tr.hourly_rate) AS actual_timesheet_cost, (SUM(pe.amount) + SUM(te.hours * tr.hourly_rate)) - pb.planned_amount AS profitability \nFROM projects p \nJOIN project_budgets pb ON p.project_id = pb.project_id \nLEFT JOIN project_expenses pe ON p.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2021 \nLEFT JOIN timesheets ts ON p.project_id = ts.project_id AND EXTRACT(YEAR FROM ts.week_start_date) = 2021 \nLEFT JOIN timesheet_entries te ON ts.timesheet_id = te.timesheet_id \nLEFT JOIN project_resources tr ON p.project_id = tr.project_id \nWHERE EXTRACT(YEAR FROM p.start_date) = 2021\nGROUP BY p.project_id LIMIT 1000;",
      "gold_sql": "  SELECT p.name,\n         pb.planned_amount AS budget,\n         COALESCE(SUM(DISTINCT pe.amount), 0) AS total_expenses,\n         COALESCE(SUM(te.hours), 0) AS total_hours,\n         pb.planned_amount - COALESCE(SUM(DISTINCT pe.amount), 0) AS profit_margin\n  FROM div_11.projects p\n  JOIN div_11.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_11.project_expenses pe ON pe.project_id = p.project_id\n  LEFT JOIN div_11.timesheets ts ON ts.employee_id IN (\n    SELECT employee_id FROM div_11.project_resources WHERE project_id = p.project_id\n  )\n  LEFT JOIN div_11.timesheet_entries te ON te.timesheet_id = ts.timesheet_id\n  WHERE EXTRACT(YEAR FROM p.start_date) = 2021\n  GROUP BY p.name, pb.planned_amount\n  ORDER BY profit_margin DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column ts.project_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 31987,
      "tags": "projects,multi_join"
    },
    {
      "qid": "Q0228",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Year-over-year sales growth comparing 2022 to the prior year.",
      "target_schema": "div_07",
      "sql_generated": "SELECT \n        EXTRACT(YEAR FROM o.order_date) AS year,\n        SUM(ol.line_total) AS total_sales\n    FROM \n        sales_orders o\n    JOIN \n        order_lines ol ON o.order_id = ol.order_id\n    WHERE \n        o.order_date BETWEEN '2021-01-01' AND '2021-12-31'\n    GROUP BY \n        year\n)\nSELECT \n    current.year AS current_year,\n    previous.year AS previous_year,\n    (current.total_sales - previous.total_sales) * 100.0 / NULLIF(previous.total_sales, 0) AS growth_pct\nFROM \n    yearly_sales current\nJOIN \n    yearly_sales previous ON current.year = previous.year + 1;",
      "gold_sql": "  WITH yearly AS (\n    SELECT EXTRACT(YEAR FROM so.order_date) AS yr,\n           SUM(ol.quantity * ol.unit_price) AS total_sales\n    FROM div_07.order_lines ol\n    JOIN div_07.sales_orders so ON so.order_id = ol.order_id\n    WHERE EXTRACT(YEAR FROM so.order_date) IN (2022, 2022 - 1)\n    GROUP BY yr\n  )\n  SELECT\n    cur.total_sales AS current_year_sales,\n    prev.total_sales AS prior_year_sales,\n    ROUND(100.0 * (cur.total_sales - prev.total_sales) / NULLIF(prev.total_sales, 0), 2) AS growth_pct\n  FROM yearly cur\n  JOIN yearly prev ON cur.yr = prev.yr + 1;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 22323,
      "tags": "sales,temporal"
    },
    {
      "qid": "Q0229",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Count inventory adjustments by reason in 2023.",
      "target_schema": "div_04",
      "sql_generated": "SELECT reason, COUNT(*) AS adjustment_count FROM inventory_adjustments WHERE adjustment_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY reason LIMIT 1000;",
      "gold_sql": "  SELECT reason, COUNT(*) AS adjustment_count\n  FROM div_04.inventory_adjustments\n  WHERE EXTRACT(YEAR FROM adjustment_date) = 2023\n  GROUP BY reason;",
      "success": true,
      "latency_ms": 5922,
      "tags": "inventory"
    },
    {
      "qid": "Q0230",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Departments where actual expenses exceed budget in 2024.",
      "target_schema": "div_01",
      "sql_generated": "SELECT \n    b.department_id,\n    d.name AS department_name,\n    SUM(pe.amount) AS actual_expenses,\n    SUM(pb.planned_amount) AS budgeted_amount\nFROM \n    project_budgets pb\nJOIN \n    projects p ON pb.project_id = p.project_id\nJOIN \n    project_expenses pe ON p.project_id = pe.project_id\nJOIN \n    budgets b ON pb.budget_id = b.budget_id\nJOIN \n    departments d ON b.department_id = d.department_id\nWHERE \n    EXTRACT(YEAR FROM pe.expense_date) = 2024\nGROUP BY \n    b.department_id, d.name\nHAVING \n    SUM(pe.amount) > SUM(pb.planned_amount);",
      "gold_sql": "  SELECT d.name, b.total_amount, COALESCE(SUM(pe.amount),0) AS actual_spend\n  FROM div_01.budgets b\n  JOIN div_01.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_01.project_expenses pe ON pe.project_id IS NOT NULL\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2024\n  GROUP BY d.name, b.total_amount\n  HAVING COALESCE(SUM(pe.amount),0) > b.total_amount;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21875,
      "tags": "finance,projects"
    },
    {
      "qid": "Q0231",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_10.svc_statements_of_work sow\n  JOIN div_10.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": true,
      "latency_ms": 11602,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0232",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2021.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pc.name AS product_category, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS turns FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN inventory_transactions it ON p.product_id = it.product_id WHERE date_trunc('year', it.transaction_date) = '2021-01-01' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_14.inventory_transactions it\n  JOIN div_14.products p ON p.product_id = it.product_id\n  JOIN div_14.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2021\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 10834,
      "tags": "inventory"
    },
    {
      "qid": "Q0233",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Complete employee profile: department, position, salary, benefits, certifications for 2021.",
      "target_schema": "div_07",
      "sql_generated": "SELECT d.name AS department, p.title AS position, s.amount AS salary, b.benefit_type_id, b.coverage_level, c.certification_id, c.expiry_date FROM employees e JOIN departments d ON e.department_id = d.department_id JOIN positions p ON e.position_id = p.position_id JOIN employee_salaries s ON e.employee_id = s.employee_id AND s.effective_date <= '2021-12-31' AND (s.end_date IS NULL OR s.end_date >= '2021-01-01') LEFT JOIN hr_benefit_elections b ON e.employee_id = b.employee_id LEFT JOIN employee_certifications c ON e.employee_id = c.employee_id LIMIT 1000;",
      "gold_sql": "  SELECT e.first_name, e.last_name,\n         d.name AS department,\n         pos.title AS position,\n         es.amount AS salary,\n         COUNT(DISTINCT be.election_id) AS benefit_elections,\n         COUNT(DISTINCT ec.certification_id) AS certifications\n  FROM div_07.employees e\n  JOIN div_07.departments d ON d.department_id = e.department_id\n  LEFT JOIN div_07.positions pos ON pos.position_id = e.position_id\n  LEFT JOIN div_07.employee_salaries es ON es.employee_id = e.employee_id\n    AND es.effective_date <= DATE '2021-12-31'\n  LEFT JOIN div_07.hr_benefit_elections be ON be.employee_id = e.employee_id\n    AND EXTRACT(YEAR FROM be.election_date) = 2021\n  LEFT JOIN div_07.employee_certifications ec ON ec.employee_id = e.employee_id\n  GROUP BY e.first_name, e.last_name, d.name, pos.title, es.amount\n  LIMIT 50;",
      "success": true,
      "latency_ms": 21420,
      "tags": "hr,multi_join"
    },
    {
      "qid": "Q0234",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total journal line amounts by cost center for 2022.",
      "target_schema": "div_02",
      "sql_generated": "SELECT j.cost_center_id, SUM(j.debit - j.credit) AS total_amount FROM journal_lines j JOIN journal_entries e ON j.entry_id = e.entry_id WHERE date_trunc('year', e.entry_date) = '2022-01-01' GROUP BY j.cost_center_id LIMIT 1000;",
      "gold_sql": "  SELECT cc.name, SUM(jl.debit - jl.credit) AS net_amount\n  FROM div_02.journal_lines jl\n  JOIN div_02.journal_entries je ON je.entry_id = jl.entry_id\n  JOIN div_02.cost_centers cc ON cc.cost_center_id = jl.cost_center_id\n  WHERE EXTRACT(YEAR FROM je.entry_date) = 2022\n  GROUP BY cc.name;",
      "success": true,
      "latency_ms": 11421,
      "tags": "finance"
    },
    {
      "qid": "Q0235",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Show onboarding tasks overdue as of today.",
      "target_schema": "div_06",
      "sql_generated": "SELECT task_id, name, description, due_date, completed_date, status FROM project_tasks WHERE status != 'Done' AND due_date < CURRENT_DATE LIMIT 1000;",
      "gold_sql": "  SELECT task_id, employee_id, task_name, due_date, status\n  FROM div_06.hr_onboarding_tasks\n  WHERE status <> 'done'\n    AND due_date < CURRENT_DATE;",
      "success": true,
      "latency_ms": 5943,
      "tags": "hr"
    },
    {
      "qid": "Q0236",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Number of journal entries by month in 2023.",
      "target_schema": "div_08",
      "sql_generated": "SELECT date_trunc('month', entry_date) AS month, COUNT(*) AS num_entries FROM journal_entries WHERE EXTRACT(YEAR FROM entry_date) = 2023 GROUP BY month ORDER BY month LIMIT 1000;",
      "gold_sql": "  SELECT DATE_TRUNC('month', entry_date) AS month, COUNT(*) AS entry_count\n  FROM div_08.journal_entries\n  WHERE EXTRACT(YEAR FROM entry_date) = 2023\n  GROUP BY month\n  ORDER BY month;",
      "success": true,
      "latency_ms": 7835,
      "tags": "finance"
    },
    {
      "qid": "Q0237",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_03.",
      "target_schema": "div_03",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_03.mfg_work_orders wo\n  JOIN div_03.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 12204,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0238",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Procure-to-pay cycle: PO to receipt to invoice for each vendor in 2023.",
      "target_schema": "div_13",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, p.po_number, gr.receipt_number, vi.invoice_number, p.order_date, gr.receipt_date, vi.invoice_date \nFROM purchase_orders p \nJOIN goods_receipts gr ON p.po_id = gr.po_id \nJOIN vendor_invoices vi ON gr.receipt_id = vi.receipt_id \nJOIN vendors v ON vi.vendor_id = v.vendor_id \nWHERE EXTRACT(YEAR FROM p.order_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT v.name AS vendor,\n         po.po_id,\n         po.order_date,\n         gr.receipt_id,\n         gr.receipt_date,\n         vi.invoice_id,\n         vi.invoice_date,\n         vi.total AS invoice_total\n  FROM div_13.purchase_orders po\n  JOIN div_13.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_13.vendor_invoices vi ON vi.po_id = po.po_id\n  JOIN div_13.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2023\n  ORDER BY po.order_date\n  LIMIT 50;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column vi.receipt_id does not exist",
      "sqlstate": "42703",
      "latency_ms": 21120,
      "tags": "procurement,multi_join"
    },
    {
      "qid": "Q0239",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inventory lots expiring within 60 days.",
      "target_schema": "div_04",
      "sql_generated": "SELECT lot_id, product_id, warehouse_id, lot_number, received_date, expiration_date, quantity FROM inventory_lots WHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' LIMIT 1000;",
      "gold_sql": "  SELECT lot_id, lot_number, expiration_date\n  FROM div_04.inventory_lots\n  WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';",
      "success": true,
      "latency_ms": 6714,
      "tags": "inventory"
    },
    {
      "qid": "Q0240",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Primary contacts for all customers.",
      "target_schema": "div_08",
      "sql_generated": "SELECT c.customer_id, cc.first_name, cc.last_name, cc.email, cc.phone, cc.title FROM customers c JOIN customer_contacts cc ON c.customer_id = cc.customer_id AND cc.is_primary = TRUE LIMIT 1000;",
      "gold_sql": "  SELECT c.name AS customer, cc.first_name || ' ' || cc.last_name AS contact, cc.email\n  FROM div_08.customers c\n  JOIN div_08.customer_contacts cc ON cc.customer_id = c.customer_id\n  WHERE cc.is_primary = TRUE\n  ORDER BY c.name;",
      "success": true,
      "latency_ms": 6736,
      "tags": "sales"
    },
    {
      "qid": "Q0241",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee utilization rate = hours logged / 40 by week in 2023.",
      "target_schema": "div_09",
      "sql_generated": "SELECT \n    week_start_date AS week,\n    SUM(hours) / 40.0 AS utilization_rate\nFROM \n    timesheet_entries\nWHERE \n    EXTRACT(YEAR FROM week_start_date) = 2023\nGROUP BY \n    week_start_date LIMIT 1000;",
      "gold_sql": "  SELECT e.employee_id, DATE_TRUNC('week', t.week_start_date) AS week_start,\n         ROUND(SUM(te.hours) / 40.0, 2) AS utilization\n  FROM div_09.timesheets t\n  JOIN div_09.timesheet_entries te ON te.timesheet_id = t.timesheet_id\n  JOIN div_09.employees e ON e.employee_id = t.employee_id\n  WHERE EXTRACT(YEAR FROM t.week_start_date) = 2023\n  GROUP BY e.employee_id, week_start;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"week_start_date\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 13471,
      "tags": "projects,hr"
    },
    {
      "qid": "Q0242",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List open AR invoices over 10000 in 2023.",
      "target_schema": "div_10",
      "sql_generated": "SELECT ar_invoice_id, invoice_number, customer_id, invoice_date, due_date, amount, status FROM finance_ar_invoices WHERE status = 'Open' AND amount > 10000 AND EXTRACT(YEAR FROM invoice_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT ar_invoice_id, invoice_number, amount, status\n  FROM div_10.finance_ar_invoices\n  WHERE status = 'open'\n    AND amount > 10000\n    AND EXTRACT(YEAR FROM invoice_date) = 2023;",
      "success": true,
      "latency_ms": 6298,
      "tags": "finance,ar"
    },
    {
      "qid": "Q0243",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Vendor invoices past due as of today.",
      "target_schema": "div_01",
      "sql_generated": "SELECT invoice_id, invoice_number, vendor_id, due_date, status FROM vendor_invoices WHERE due_date < CURRENT_DATE AND status = 'Unpaid' LIMIT 1000;",
      "gold_sql": "  SELECT invoice_id, vendor_id, due_date, total, status\n  FROM div_01.vendor_invoices\n  WHERE due_date < CURRENT_DATE AND status <> 'paid';",
      "success": true,
      "latency_ms": 5299,
      "tags": "procurement"
    },
    {
      "qid": "Q0244",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Projects where actual expenses exceed project budget.",
      "target_schema": "div_17",
      "sql_generated": "SELECT p.project_id, p.name, pb.budget_id, pb.planned_amount, SUM(pe.amount) AS total_expenses FROM projects p JOIN project_budgets pb ON p.project_id = pb.project_id LEFT JOIN project_expenses pe ON p.project_id = pe.project_id GROUP BY p.project_id, p.name, pb.budget_id, pb.planned_amount HAVING SUM(pe.amount) > pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.project_id, p.name\n  FROM div_17.projects p\n  JOIN div_17.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_17.project_expenses pe ON pe.project_id = p.project_id\n  GROUP BY p.project_id, p.name, pb.planned_amount\n  HAVING COALESCE(SUM(pe.amount),0) > pb.planned_amount;",
      "success": true,
      "latency_ms": 11811,
      "tags": "projects"
    },
    {
      "qid": "Q0245",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Budget variance (planned vs actual) by department for 2023.",
      "target_schema": "div_11",
      "sql_generated": "SELECT \n    b.department_id,\n    SUM(pb.planned_amount) AS planned_amount,\n    SUM(pe.amount) AS actual_amount,\n    (SUM(pe.amount) - SUM(pb.planned_amount)) AS variance\nFROM \n    budgets b\nJOIN \n    project_budgets pb ON b.budget_id = pb.budget_id\nJOIN \n    project_expenses pe ON pb.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2023\nGROUP BY \n    b.department_id LIMIT 1000;",
      "gold_sql": "  SELECT d.name,\n         b.total_amount AS planned,\n         COALESCE(SUM(pe.amount), 0) AS actual,\n         b.total_amount - COALESCE(SUM(pe.amount), 0) AS variance\n  FROM div_11.budgets b\n  JOIN div_11.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_11.project_expenses pe ON pe.project_id IN (\n    SELECT project_id FROM div_11.projects WHERE customer_id IS NOT NULL\n  ) AND EXTRACT(YEAR FROM pe.expense_date) = 2023\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2023\n  GROUP BY d.name, b.total_amount\n  ORDER BY variance;",
      "success": true,
      "latency_ms": 19782,
      "tags": "finance,budget"
    },
    {
      "qid": "Q0246",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Quarterly revenue comparison for 2022.",
      "target_schema": "div_07",
      "sql_generated": "SELECT date_trunc('quarter', o.order_date) AS quarter, SUM(ol.quantity * ol.unit_price) AS revenue FROM sales_orders o JOIN order_lines ol ON o.order_id = ol.order_id WHERE o.order_date >= '2022-01-01' AND o.order_date < '2023-01-01' GROUP BY quarter ORDER BY quarter LIMIT 1000;",
      "gold_sql": "  SELECT\n    EXTRACT(QUARTER FROM so.order_date) AS quarter,\n    SUM(ol.quantity * ol.unit_price) AS revenue\n  FROM div_07.order_lines ol\n  JOIN div_07.sales_orders so ON so.order_id = ol.order_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY quarter\n  ORDER BY quarter;",
      "success": true,
      "latency_ms": 13485,
      "tags": "sales,temporal"
    },
    {
      "qid": "Q0247",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total maintenance cost by asset category in 2021.",
      "target_schema": "div_11",
      "sql_generated": "SELECT ac.name AS category_name, SUM(am.cost) AS total_maintenance_cost FROM asset_maintenance am JOIN fixed_assets fa ON am.asset_id = fa.asset_id JOIN asset_categories ac ON fa.category_id = ac.category_id WHERE date_trunc('year', am.scheduled_date) = '2021-01-01' GROUP BY ac.name LIMIT 1000;",
      "gold_sql": "  SELECT ac.name, SUM(am.cost) AS total_cost\n  FROM div_11.asset_maintenance am\n  JOIN div_11.fixed_assets fa ON fa.asset_id = am.asset_id\n  JOIN div_11.asset_categories ac ON ac.category_id = fa.category_id\n  WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2021\n  GROUP BY ac.name;",
      "success": true,
      "latency_ms": 8261,
      "tags": "assets"
    },
    {
      "qid": "Q0248",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Open audit findings by severity and type for corporate division div_16.",
      "target_schema": "div_16",
      "sql_generated": "SELECT severity, type, COUNT(*) AS finding_count FROM corp_audit_findings WHERE division_id = 'div_16' AND status_code IN ('OP', 'IP') GROUP BY severity, type LIMIT 1000;",
      "gold_sql": "  SELECT audit_type, severity, COUNT(*) AS finding_count\n  FROM div_16.corp_audit_findings\n  WHERE status_code IN ('OP', 'IP')\n  GROUP BY audit_type, severity\n  ORDER BY severity, finding_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"type\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 9179,
      "tags": "corporate"
    },
    {
      "qid": "Q0249",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_05.",
      "target_schema": "div_05",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(mwo.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders mwo\nJOIN \n    lookup_codes l ON mwo.status_code = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status,\n         COUNT(*) AS wo_count\n  FROM div_05.mfg_work_orders wo\n  JOIN div_05.lookup_codes lc ON lc.code = wo.status_code AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 13741,
      "tags": "manufacturing,lookup"
    },
    {
      "qid": "Q0250",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Consolidation totals by currency with FX impact for corporate division div_17.",
      "target_schema": "div_17",
      "sql_generated": "SELECT currency_code, SUM(original_amount) AS original_total, SUM(translated_amount) AS translated_total, SUM(translated_amount - original_amount) AS fx_impact FROM corp_consolidation_entries WHERE source_division = 'div_17' GROUP BY currency_code LIMIT 1000;",
      "gold_sql": "  SELECT currency_code,\n         SUM(original_amount) AS total_original,\n         SUM(translated_amount) AS total_translated,\n         SUM(translated_amount - original_amount) AS fx_impact,\n         COUNT(*) AS entry_count\n  FROM div_17.corp_consolidation_entries\n  GROUP BY currency_code\n  ORDER BY total_original DESC;",
      "success": true,
      "latency_ms": 8444,
      "tags": "corporate"
    },
    {
      "qid": "Q0251",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from RFQ to vendor response for 2023.",
      "target_schema": "div_15",
      "sql_generated": "SELECT AVG(response_date - rfq_date) AS avg_days_to_response FROM procurement_rfqs rfqs JOIN procurement_rfq_responses responses ON rfqs.rfq_id = responses.rfq_id WHERE EXTRACT(YEAR FROM rfqs.rfq_date) = 2023 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(r.response_date - q.rfq_date), 2) AS avg_days\n  FROM div_15.procurement_rfqs q\n  JOIN div_15.procurement_rfq_responses r ON r.rfq_id = q.rfq_id\n  WHERE EXTRACT(YEAR FROM q.rfq_date) = 2023;",
      "success": true,
      "latency_ms": 9109,
      "tags": "procurement,time"
    },
    {
      "qid": "Q0252",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total contract value by customer for services division div_07.",
      "target_schema": "div_07",
      "sql_generated": "SELECT c.customer_id, c.name AS customer_name, SUM(s.tot_amt) AS total_contract_value FROM zz_svc_sow s JOIN customers c ON s.cust_nbr = c.customer_id GROUP BY c.customer_id, c.name LIMIT 1000;",
      "gold_sql": "  SELECT c.name, SUM(sow.tot_amt) AS total_value, COUNT(*) AS sow_count\n  FROM div_07.zz_svc_sow sow\n  JOIN div_07.customers c ON c.customer_id = sow.cust_nbr\n  GROUP BY c.name\n  ORDER BY total_value DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 7742,
      "tags": "services,dirty_naming"
    },
    {
      "qid": "Q0253",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Benefit election count by coverage level in 2022.",
      "target_schema": "div_01",
      "sql_generated": "SELECT coverage_level, COUNT(*) AS benefit_election_count FROM hr_benefit_elections WHERE DATE_TRUNC('year', election_date) = '2022-01-01' GROUP BY coverage_level LIMIT 1000;",
      "gold_sql": "  SELECT coverage_level, COUNT(*) AS elections\n  FROM div_01.hr_benefit_elections\n  WHERE EXTRACT(YEAR FROM election_date) = 2022\n  GROUP BY coverage_level;",
      "success": true,
      "latency_ms": 6522,
      "tags": "hr,benefits"
    },
    {
      "qid": "Q0254",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Sales order counts by status for 2022.",
      "target_schema": "div_04",
      "sql_generated": "SELECT status, COUNT(order_id) AS count FROM sales_orders WHERE order_date >= '2022-01-01' AND order_date < '2023-01-01' GROUP BY status LIMIT 1000;",
      "gold_sql": "  SELECT status, COUNT(*) AS order_count\n  FROM div_04.sales_orders\n  WHERE EXTRACT(YEAR FROM order_date) = 2022\n  GROUP BY status;",
      "success": true,
      "latency_ms": 4357,
      "tags": "sales"
    },
    {
      "qid": "Q0255",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Project margin = (budget - actual expenses) for active projects in 2023.",
      "target_schema": "div_16",
      "sql_generated": "SELECT p.project_id, p.name AS project_name, pb.planned_amount AS budget, SUM(pe.amount) AS actual_expenses, (pb.planned_amount - SUM(pe.amount)) AS margin FROM projects p JOIN project_budgets pb ON p.project_id = pb.project_id LEFT JOIN project_expenses pe ON p.project_id = pe.project_id AND pe.status = 'Approved' WHERE p.status = 'Active' AND EXTRACT(YEAR FROM p.start_date) = 2023 GROUP BY p.project_id, p.name, pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.project_id, p.name,\n         pb.planned_amount - COALESCE(SUM(pe.amount),0) AS margin\n  FROM div_16.projects p\n  JOIN div_16.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_16.project_expenses pe ON pe.project_id = p.project_id\n  WHERE p.status = 'active'\n    AND EXTRACT(YEAR FROM p.start_date) = 2023\n  GROUP BY p.project_id, p.name, pb.planned_amount\n  ORDER BY margin DESC;",
      "success": true,
      "latency_ms": 18209,
      "tags": "projects"
    },
    {
      "qid": "Q0256",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List inventory lots expiring within 60 days.",
      "target_schema": "div_10",
      "sql_generated": "SELECT lot_id, product_id, warehouse_id, lot_number, received_date, expiration_date, quantity FROM inventory_lots WHERE expiration_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '60 days' LIMIT 1000;",
      "gold_sql": "  SELECT lot_id, lot_number, expiration_date\n  FROM div_10.inventory_lots\n  WHERE expiration_date <= CURRENT_DATE + INTERVAL '60 days';",
      "success": true,
      "latency_ms": 6782,
      "tags": "inventory"
    },
    {
      "qid": "Q0257",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee turnover rate for 2022.",
      "target_schema": "div_13",
      "sql_generated": "SELECT AVG(CASE WHEN termination_date BETWEEN '2022-01-01' AND '2022-12-31' THEN 1 ELSE 0 END) AS turnover_rate FROM employees LIMIT 1000;",
      "gold_sql": "  WITH terminations AS (\n    SELECT COUNT(*) AS term_count\n    FROM div_13.employees\n    WHERE EXTRACT(YEAR FROM termination_date) = 2022\n  ),\n  headcount AS (\n    SELECT COUNT(*) AS headcount\n    FROM div_13.employees\n    WHERE hire_date <= DATE '2022-12-31'\n      AND (termination_date IS NULL OR termination_date > DATE '2022-01-01')\n  )\n  SELECT ROUND(100.0 * t.term_count / NULLIF(h.headcount,0), 2) AS turnover_pct\n  FROM terminations t, headcount h;",
      "success": true,
      "latency_ms": 8247,
      "tags": "hr"
    },
    {
      "qid": "Q0258",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total depreciation by period for 2023.",
      "target_schema": "div_06",
      "sql_generated": "SELECT period_id, SUM(amount) AS total_depreciation FROM depreciation_entries WHERE period_id IN (SELECT period_id FROM fiscal_periods WHERE fiscal_year_id = 2023) GROUP BY period_id LIMIT 1000;",
      "gold_sql": "  SELECT fp.start_date, SUM(de.amount) AS total_depr\n  FROM div_06.depreciation_entries de\n  JOIN div_06.fiscal_periods fp ON fp.period_id = de.period_id\n  WHERE EXTRACT(YEAR FROM fp.start_date) = 2023\n  GROUP BY fp.start_date\n  ORDER BY fp.start_date;",
      "success": true,
      "latency_ms": 8905,
      "tags": "assets,finance"
    },
    {
      "qid": "Q0259",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_02.",
      "target_schema": "div_02",
      "sql_generated": "SELECT l.meaning AS status, COUNT(w.wo_id) AS work_order_count \nFROM xx_mfg_wo w \nJOIN lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_02.xx_mfg_wo wo\n  JOIN div_02.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": true,
      "latency_ms": 11377,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0260",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_12.",
      "target_schema": "div_12",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_12.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6700,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0261",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Work order count by decoded status in manufacturing division div_04.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n    l.description AS status_description,\n    COUNT(w.work_order_id) AS work_order_count\nFROM \n    mfg_work_orders w\nJOIN \n    lookup_codes l ON w.sts_cd = l.code AND l.domain = 'WO_STATUS'\nGROUP BY \n    l.description;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS wo_count\n  FROM div_04.xx_mfg_wo wo\n  JOIN div_04.lookup_codes lc ON lc.code = wo.sts_cd AND lc.domain = 'WO_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY wo_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 11994,
      "tags": "manufacturing,dirty_naming,lookup"
    },
    {
      "qid": "Q0262",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Top 10 products by POS revenue for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT p.product_id, p.name, SUM(pli.line_total) AS total_revenue FROM rtl_pos_line_items pli JOIN products p ON pli.product_id = p.product_id GROUP BY p.product_id, p.name ORDER BY total_revenue DESC LIMIT 10;",
      "gold_sql": "  SELECT p.name, SUM(li.line_total) AS total_revenue,\n         SUM(li.quantity) AS units_sold\n  FROM div_11.rtl_pos_line_items li\n  JOIN div_11.products p ON p.product_id = li.product_id\n  GROUP BY p.name\n  ORDER BY total_revenue DESC\n  LIMIT 10;",
      "success": true,
      "latency_ms": 9394,
      "tags": "retail"
    },
    {
      "qid": "Q0263",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turns by product category for 2022.",
      "target_schema": "div_02",
      "sql_generated": "SELECT pc.name AS category_name, SUM(it.quantity) / NULLIF(COUNT(DISTINCT it.transaction_date), 0) AS turns_per_month FROM products p JOIN product_categories pc ON p.category_id = pc.category_id JOIN inventory_transactions it ON p.product_id = it.product_id WHERE date_trunc('year', it.transaction_date) = '2022-01-01' GROUP BY pc.name LIMIT 1000;",
      "gold_sql": "  SELECT pc.name, SUM(it.quantity) AS total_moved\n  FROM div_02.inventory_transactions it\n  JOIN div_02.products p ON p.product_id = it.product_id\n  JOIN div_02.product_categories pc ON pc.category_id = p.category_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2022\n  GROUP BY pc.name\n  ORDER BY total_moved DESC;",
      "success": true,
      "latency_ms": 10939,
      "tags": "inventory"
    },
    {
      "qid": "Q0264",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Budget variance (planned vs actual) by department for 2022.",
      "target_schema": "div_10",
      "sql_generated": "SELECT \n    b.department_id,\n    SUM(pb.planned_amount) AS planned_amount,\n    SUM(pe.amount) AS actual_amount,\n    (SUM(pe.amount) - SUM(pb.planned_amount)) AS variance\nFROM \n    budgets b\nJOIN \n    project_budgets pb ON b.budget_id = pb.budget_id\nLEFT JOIN \n    project_expenses pe ON pb.project_id = pe.project_id AND EXTRACT(YEAR FROM pe.expense_date) = 2022\nGROUP BY \n    b.department_id LIMIT 1000;",
      "gold_sql": "  SELECT d.name,\n         b.total_amount AS planned,\n         COALESCE(SUM(pe.amount), 0) AS actual,\n         b.total_amount - COALESCE(SUM(pe.amount), 0) AS variance\n  FROM div_10.budgets b\n  JOIN div_10.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_10.project_expenses pe ON pe.project_id IN (\n    SELECT project_id FROM div_10.projects WHERE customer_id IS NOT NULL\n  ) AND EXTRACT(YEAR FROM pe.expense_date) = 2022\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2022\n  GROUP BY d.name, b.total_amount\n  ORDER BY variance;",
      "success": true,
      "latency_ms": 20725,
      "tags": "finance,budget"
    },
    {
      "qid": "Q0265",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_14.",
      "target_schema": "div_14",
      "sql_generated": "SELECT pay_mthd_cd, SUM(tot_amt) AS total_sales FROM zz_pos_trnx WHERE trnx_dt >= CURRENT_DATE - INTERVAL '1 year' GROUP BY pay_mthd_cd LIMIT 1000;",
      "gold_sql": "  SELECT pay_mthd_cd, COUNT(*) AS txn_count,\n         SUM(tot_amt) AS total_sales\n  FROM div_14.zz_pos_trnx\n  GROUP BY pay_mthd_cd\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 7317,
      "tags": "retail,dirty_naming"
    },
    {
      "qid": "Q0266",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Sales order count by sales region for 2024.",
      "target_schema": "div_07",
      "sql_generated": "SELECT sr.name AS region_name, COUNT(so.order_id) AS order_count\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nJOIN customer_ship_to_sites css ON c.customer_id = css.customer_id\nJOIN addresses a ON css.address_id = a.address_id\nJOIN cities ci ON a.city_id = ci.city_id\nJOIN states_provinces sp ON ci.state_id = sp.state_id\nJOIN countries co ON sp.country_id = co.country_id\nJOIN sales_regions sr ON ci.state_id = sr.region_id\nWHERE EXTRACT(YEAR FROM so.order_date) = 2024\nGROUP BY sr.name;",
      "gold_sql": "  SELECT s.name AS state, COUNT(*) AS order_count\n  FROM div_07.sales_orders so\n  JOIN div_07.customers c ON c.customer_id = so.customer_id\n  LEFT JOIN div_07.addresses a ON a.address_id = c.billing_address_id\n  LEFT JOIN div_07.cities ci ON ci.city_id = a.city_id\n  LEFT JOIN div_07.states_provinces s ON s.state_id = ci.state_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2024\n  GROUP BY s.name\n  ORDER BY order_count DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 20926,
      "tags": "sales,geography"
    },
    {
      "qid": "Q0267",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Aged AR receivables buckets (0-30, 31-60, 61-90, 90+) for 2024.",
      "target_schema": "div_12",
      "sql_generated": "SELECT CASE WHEN invoice_date >= CURRENT_DATE - INTERVAL '30 days' THEN '0-30' WHEN invoice_date < CURRENT_DATE - INTERVAL '30 days' AND invoice_date >= CURRENT_DATE - INTERVAL '60 days' THEN '31-60' WHEN invoice_date < CURRENT_DATE - INTERVAL '60 days' AND invoice_date >= CURRENT_DATE - INTERVAL '90 days' THEN '61-90' ELSE '90+' END AS age_bucket, COUNT(*) AS count FROM finance_ar_invoices WHERE status = 'open' AND EXTRACT(YEAR FROM due_date) = 2024 GROUP BY age_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN CURRENT_DATE - due_date <= 30 THEN '0-30'\n      WHEN CURRENT_DATE - due_date <= 60 THEN '31-60'\n      WHEN CURRENT_DATE - due_date <= 90 THEN '61-90'\n      ELSE '90+'\n    END AS aging_bucket,\n    COUNT(*) AS invoice_count,\n    SUM(amount) AS total_amount\n  FROM div_12.finance_ar_invoices\n  WHERE status = 'open'\n    AND EXTRACT(YEAR FROM invoice_date) = 2024\n  GROUP BY aging_bucket\n  ORDER BY aging_bucket;",
      "success": true,
      "latency_ms": 19562,
      "tags": "finance,ar,aging"
    },
    {
      "qid": "Q0268",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Loyalty member count by tier for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT tier_code, COUNT(*) AS member_count FROM rtl_loyalty_members WHERE tier_code IN ('BZ', 'SV', 'GD', 'PT') GROUP BY tier_code LIMIT 1000;",
      "gold_sql": "  SELECT tier_code, COUNT(*) AS member_count,\n         AVG(points_balance) AS avg_points\n  FROM div_11.rtl_loyalty_members\n  WHERE status_code = 'AC'\n  GROUP BY tier_code\n  ORDER BY member_count DESC;",
      "success": true,
      "latency_ms": 6522,
      "tags": "retail,lookup"
    },
    {
      "qid": "Q0269",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Open audit findings by severity and type for corporate division div_17.",
      "target_schema": "div_17",
      "sql_generated": "SELECT severity, type, COUNT(*) AS finding_count FROM corp_audit_findings WHERE department_id = 'div_17' AND status_code IN ('OP', 'IP') GROUP BY severity, type LIMIT 1000;",
      "gold_sql": "  SELECT audit_type, severity, COUNT(*) AS finding_count\n  FROM div_17.corp_audit_findings\n  WHERE status_code IN ('OP', 'IP')\n  GROUP BY audit_type, severity\n  ORDER BY severity, finding_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"type\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 9087,
      "tags": "corporate"
    },
    {
      "qid": "Q0270",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Number of journal entries by month in 2022.",
      "target_schema": "div_01",
      "sql_generated": "SELECT date_trunc('month', entry_date) AS month, COUNT(entry_id) AS num_entries FROM journal_entries WHERE entry_date >= '2022-01-01' AND entry_date < '2023-01-01' GROUP BY month ORDER BY month LIMIT 1000;",
      "gold_sql": "  SELECT DATE_TRUNC('month', entry_date) AS month, COUNT(*) AS entry_count\n  FROM div_01.journal_entries\n  WHERE EXTRACT(YEAR FROM entry_date) = 2022\n  GROUP BY month\n  ORDER BY month;",
      "success": true,
      "latency_ms": 7049,
      "tags": "finance"
    },
    {
      "qid": "Q0271",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Projects where actual expenses exceed project budget.",
      "target_schema": "div_02",
      "sql_generated": "SELECT p.project_id, p.name, pb.budget_id, pb.planned_amount, SUM(pe.amount) AS total_expenses FROM projects p JOIN project_budgets pb ON p.project_id = pb.project_id LEFT JOIN project_expenses pe ON p.project_id = pe.project_id GROUP BY p.project_id, p.name, pb.budget_id, pb.planned_amount HAVING SUM(pe.amount) > pb.planned_amount LIMIT 1000;",
      "gold_sql": "  SELECT p.project_id, p.name\n  FROM div_02.projects p\n  JOIN div_02.project_budgets pb ON pb.project_id = p.project_id\n  LEFT JOIN div_02.project_expenses pe ON pe.project_id = p.project_id\n  GROUP BY p.project_id, p.name, pb.planned_amount\n  HAVING COALESCE(SUM(pe.amount),0) > pb.planned_amount;",
      "success": true,
      "latency_ms": 11780,
      "tags": "projects"
    },
    {
      "qid": "Q0272",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top 10 customers by total sales amount in 2022?",
      "target_schema": "div_06",
      "sql_generated": "",
      "gold_sql": "  SELECT c.name, SUM(ol.quantity * ol.unit_price) AS total_sales\n  FROM div_06.sales_orders so\n  JOIN div_06.order_lines ol ON ol.order_id = so.order_id\n  JOIN div_06.customers c ON c.customer_id = so.customer_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY c.name\n  ORDER BY total_sales DESC\n  LIMIT 10;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 15704,
      "tags": "sales,top_n,aggregation"
    },
    {
      "qid": "Q0273",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Top 10 customers by total sales amount in 2022?",
      "target_schema": "div_17",
      "sql_generated": "",
      "gold_sql": "  SELECT c.name, SUM(ol.quantity * ol.unit_price) AS total_sales\n  FROM div_17.sales_orders so\n  JOIN div_17.order_lines ol ON ol.order_id = so.order_id\n  JOIN div_17.customers c ON c.customer_id = so.customer_id\n  WHERE EXTRACT(YEAR FROM so.order_date) = 2022\n  GROUP BY c.name\n  ORDER BY total_sales DESC\n  LIMIT 10;",
      "success": false,
      "error_type": "internal",
      "error_message": "Internal error: cannot access local variable 'schema' where it is not associated with a value",
      "latency_ms": 13154,
      "tags": "sales,top_n,aggregation"
    },
    {
      "qid": "Q0274",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "What percentage of AR invoices were late in 2024?",
      "target_schema": "div_19",
      "sql_generated": "SELECT SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(*), 0) AS late_percentage FROM vendor_invoices WHERE invoice_date < CURRENT_DATE AND EXTRACT(YEAR FROM invoice_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN status = 'late' THEN 1 ELSE 0 END) / COUNT(*), 2) AS late_pct\n  FROM div_19.finance_ar_invoices\n  WHERE EXTRACT(YEAR FROM invoice_date) = 2024;",
      "success": true,
      "latency_ms": 10292,
      "tags": "finance,ar,rate"
    },
    {
      "qid": "Q0275",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Procure-to-pay cycle: PO to receipt to invoice for each vendor in 2021.",
      "target_schema": "div_07",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, p.po_number, gr.receipt_number, vi.invoice_number, p.order_date, gr.receipt_date, vi.invoice_date FROM purchase_orders p JOIN goods_receipts gr ON p.po_id = gr.po_id JOIN vendor_invoices vi ON gr.receipt_id = vi.po_id JOIN vendors v ON vi.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM p.order_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT v.name AS vendor,\n         po.po_id,\n         po.order_date,\n         gr.receipt_id,\n         gr.receipt_date,\n         vi.invoice_id,\n         vi.invoice_date,\n         vi.total AS invoice_total\n  FROM div_07.purchase_orders po\n  JOIN div_07.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_07.vendor_invoices vi ON vi.po_id = po.po_id\n  JOIN div_07.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2021\n  ORDER BY po.order_date\n  LIMIT 50;",
      "success": true,
      "latency_ms": 16254,
      "tags": "procurement,multi_join"
    },
    {
      "qid": "Q0276",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Inventory turnover ratio by product category for 2022.",
      "target_schema": "div_11",
      "sql_generated": "SELECT \n    pc.name AS category_name,\n    SUM(it.quantity) / NULLIF(AVG(il.quantity_on_hand), 0) AS turnover_ratio\nFROM \n    inventory_transactions it\nJOIN \n    products p ON it.product_id = p.product_id\nJOIN \n    product_categories pc ON p.category_id = pc.category_id\nJOIN \n    inventory_levels il ON p.product_id = il.product_id AND it.warehouse_id = il.warehouse_id\nWHERE \n    EXTRACT(YEAR FROM it.transaction_date) = 2022\nGROUP BY \n    pc.name;",
      "gold_sql": "  SELECT pc.name,\n         SUM(ABS(it.quantity)) AS total_moved,\n         AVG(il.quantity_on_hand) AS avg_on_hand,\n         ROUND(SUM(ABS(it.quantity)) / NULLIF(AVG(il.quantity_on_hand), 0), 2) AS turnover_ratio\n  FROM div_11.inventory_transactions it\n  JOIN div_11.products p ON p.product_id = it.product_id\n  JOIN div_11.product_categories pc ON pc.category_id = p.category_id\n  LEFT JOIN div_11.inventory_levels il ON il.product_id = p.product_id\n  WHERE EXTRACT(YEAR FROM it.transaction_date) = 2022\n  GROUP BY pc.name\n  ORDER BY turnover_ratio DESC;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21142,
      "tags": "inventory,kpi"
    },
    {
      "qid": "Q0277",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from requisition to PO for 2024.",
      "target_schema": "div_18",
      "sql_generated": "SELECT AVG(po.order_date - pr.request_date) AS avg_days_to_po FROM purchase_requisitions pr JOIN purchase_orders po ON pr.requisition_id = po.requisition_id WHERE EXTRACT(YEAR FROM po.order_date) = 2024 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(po.order_date - pr.request_date), 2) AS avg_days\n  FROM div_18.purchase_requisitions pr\n  JOIN div_18.purchase_orders po ON po.requisition_id = pr.requisition_id\n  WHERE EXTRACT(YEAR FROM pr.request_date) = 2024;",
      "success": true,
      "latency_ms": 9913,
      "tags": "procurement"
    },
    {
      "qid": "Q0278",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Warehouse locations with low capacity (< 100).",
      "target_schema": "div_04",
      "sql_generated": "SELECT location_id, warehouse_id, aisle, rack, bin, capacity FROM warehouse_locations WHERE capacity < 100 LIMIT 1000;",
      "gold_sql": "  SELECT location_id, warehouse_id, aisle, rack, bin, capacity\n  FROM div_04.warehouse_locations\n  WHERE capacity < 100;",
      "success": true,
      "latency_ms": 4015,
      "tags": "inventory"
    },
    {
      "qid": "Q0279",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total maintenance cost by asset category in 2023.",
      "target_schema": "div_02",
      "sql_generated": "SELECT ac.name AS category_name, SUM(am.cost) AS total_cost FROM asset_maintenance am JOIN fixed_assets fa ON am.asset_id = fa.asset_id JOIN asset_categories ac ON fa.category_id = ac.category_id WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2023 GROUP BY ac.name LIMIT 1000;",
      "gold_sql": "  SELECT ac.name, SUM(am.cost) AS total_cost\n  FROM div_02.asset_maintenance am\n  JOIN div_02.fixed_assets fa ON fa.asset_id = am.asset_id\n  JOIN div_02.asset_categories ac ON ac.category_id = fa.category_id\n  WHERE EXTRACT(YEAR FROM am.scheduled_date) = 2023\n  GROUP BY ac.name;",
      "success": true,
      "latency_ms": 10210,
      "tags": "assets"
    },
    {
      "qid": "Q0280",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total scrap quantity by reason for manufacturing division div_05.",
      "target_schema": "div_05",
      "sql_generated": "SELECT reason_code, SUM(scrap_quantity) AS total_scrap_quantity \nFROM mfg_scrap_log \nWHERE work_order_id IN (SELECT work_order_id FROM mfg_work_orders WHERE department_id = 'div_05') \nGROUP BY reason_code LIMIT 1000;",
      "gold_sql": "  SELECT reason_code, SUM(scrap_quantity) AS total_scrap\n  FROM div_05.mfg_scrap_log\n  GROUP BY reason_code\n  ORDER BY total_scrap DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column \"department_id\" does not exist",
      "sqlstate": "42703",
      "latency_ms": 10460,
      "tags": "manufacturing"
    },
    {
      "qid": "Q0281",
      "difficulty": "simple",
      "template_id": "?",
      "question": "List bank accounts with balance under 1000.",
      "target_schema": "div_02",
      "sql_generated": "SELECT account_number, account_name, current_balance FROM bank_accounts WHERE current_balance < 1000 LIMIT 1000;",
      "gold_sql": "  SELECT bank_account_id, account_number, bank_name, current_balance\n  FROM div_02.bank_accounts\n  WHERE current_balance < 1000;",
      "success": true,
      "latency_ms": 4150,
      "tags": "finance"
    },
    {
      "qid": "Q0282",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of open customer service cases by priority.",
      "target_schema": "div_07",
      "sql_generated": "SELECT priority, COUNT(case_id) AS open_cases_count FROM cust_srv_case WHERE status = 'Open' GROUP BY priority LIMIT 1000;",
      "gold_sql": "  SELECT priority, COUNT(*) AS case_count\n  FROM div_07.cust_srv_case\n  WHERE status IN ('open','pending')\n  GROUP BY priority;",
      "success": true,
      "latency_ms": 4542,
      "tags": "support"
    },
    {
      "qid": "Q0283",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee tenure distribution (0-1yr, 1-3yr, 3-5yr, 5+yr) as of 2021.",
      "target_schema": "div_20",
      "sql_generated": "SELECT CASE WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 0 AND 1 THEN '0-1yr' WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 1 AND 3 THEN '1-3yr' WHEN EXTRACT(YEAR FROM AGE('2021-12-31', hire_date)) BETWEEN 3 AND 5 THEN '3-5yr' ELSE '5+yr' END AS tenure_bucket, COUNT(*) AS employee_count FROM employees WHERE termination_date IS NULL OR termination_date > '2021-12-31' GROUP BY tenure_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 1 THEN '0-1 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 3 THEN '1-3 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2021-12-31', hire_date)) < 5 THEN '3-5 yr'\n      ELSE '5+ yr'\n    END AS tenure_bucket,\n    COUNT(*) AS employee_count\n  FROM div_20.employees\n  WHERE hire_date <= DATE '2021-12-31'\n    AND (termination_date IS NULL OR termination_date > DATE '2021-12-31')\n  GROUP BY tenure_bucket\n  ORDER BY tenure_bucket;",
      "success": true,
      "latency_ms": 18271,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0284",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Consolidation totals by currency with FX impact for corporate division div_16.",
      "target_schema": "div_16",
      "sql_generated": "SELECT currency_code, SUM(original_amount) AS original_total, SUM(translated_amount) AS translated_total, SUM(translated_amount - original_amount) AS fx_impact FROM corp_consolidation_entries WHERE source_division = 'div_16' GROUP BY currency_code LIMIT 1000;",
      "gold_sql": "  SELECT currency_code,\n         SUM(original_amount) AS total_original,\n         SUM(translated_amount) AS total_translated,\n         SUM(translated_amount - original_amount) AS fx_impact,\n         COUNT(*) AS entry_count\n  FROM div_16.corp_consolidation_entries\n  GROUP BY currency_code\n  ORDER BY total_original DESC;",
      "success": true,
      "latency_ms": 10337,
      "tags": "corporate"
    },
    {
      "qid": "Q0285",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nWHERE s.division = 'div_06' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_06.svc_statements_of_work sow\n  JOIN div_06.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column s.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 13492,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0286",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Average days between vendor invoice date and due date by vendor.",
      "target_schema": "div_19",
      "sql_generated": "SELECT vendor_id, AVG(due_date - invoice_date) AS avg_days_between_due_and_invoice FROM vendor_invoices GROUP BY vendor_id LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(vi.due_date - vi.invoice_date)::numeric, 2) AS avg_days\n  FROM div_19.vendor_invoices vi\n  JOIN div_19.vendors v ON v.vendor_id = vi.vendor_id\n  GROUP BY v.name\n  ORDER BY avg_days DESC;",
      "success": true,
      "latency_ms": 5286,
      "tags": "procurement"
    },
    {
      "qid": "Q0287",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Year-over-year sales growth comparing 2024 to the prior year.",
      "target_schema": "div_04",
      "sql_generated": "SELECT \n        EXTRACT(YEAR FROM o.order_date) AS year,\n        SUM(ol.line_total) AS total_sales\n    FROM \n        sales_orders o\n    JOIN \n        order_lines ol ON o.order_id = ol.order_id\n    WHERE \n        o.order_date BETWEEN '2023-01-01' AND '2023-12-31'\n    GROUP BY \n        year\n)\nSELECT \n    current.year AS current_year,\n    previous.year AS previous_year,\n    (current.total_sales - previous.total_sales) * 100.0 / NULLIF(previous.total_sales, 0) AS growth_pct\nFROM \n    yearly_sales current\nJOIN \n    yearly_sales previous ON current.year = previous.year + 1;",
      "gold_sql": "  WITH yearly AS (\n    SELECT EXTRACT(YEAR FROM so.order_date) AS yr,\n           SUM(ol.quantity * ol.unit_price) AS total_sales\n    FROM div_04.order_lines ol\n    JOIN div_04.sales_orders so ON so.order_id = ol.order_id\n    WHERE EXTRACT(YEAR FROM so.order_date) IN (2024, 2024 - 1)\n    GROUP BY yr\n  )\n  SELECT\n    cur.total_sales AS current_year_sales,\n    prev.total_sales AS prior_year_sales,\n    ROUND(100.0 * (cur.total_sales - prev.total_sales) / NULLIF(prev.total_sales, 0), 2) AS growth_pct\n  FROM yearly cur\n  JOIN yearly prev ON cur.yr = prev.yr + 1;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 24431,
      "tags": "sales,temporal"
    },
    {
      "qid": "Q0288",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Billing milestones past due and not yet invoiced for services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT milestone_id, sow_id, milestone_number, description, amount, due_date FROM svc_billing_milestones WHERE due_date < CURRENT_DATE AND invoice_date IS NULL LIMIT 1000;",
      "gold_sql": "  SELECT sow.sow_number, bm.description, bm.amount, bm.due_date\n  FROM div_10.svc_billing_milestones bm\n  JOIN div_10.svc_statements_of_work sow ON sow.sow_id = bm.sow_id\n  WHERE bm.due_date < CURRENT_DATE AND bm.invoice_date IS NULL\n  ORDER BY bm.due_date;",
      "success": true,
      "latency_ms": 3803,
      "tags": "services"
    },
    {
      "qid": "Q0289",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Primary contacts for all customers.",
      "target_schema": "div_01",
      "sql_generated": "SELECT c.customer_id, cc.first_name, cc.last_name, cc.email, cc.phone, cc.title FROM customers c JOIN customer_contacts cc ON c.customer_id = cc.customer_id AND cc.is_primary = TRUE LIMIT 1000;",
      "gold_sql": "  SELECT c.name AS customer, cc.first_name || ' ' || cc.last_name AS contact, cc.email\n  FROM div_01.customers c\n  JOIN div_01.customer_contacts cc ON cc.customer_id = c.customer_id\n  WHERE cc.is_primary = TRUE\n  ORDER BY c.name;",
      "success": true,
      "latency_ms": 6695,
      "tags": "sales"
    },
    {
      "qid": "Q0290",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Employee tenure distribution (0-1yr, 1-3yr, 3-5yr, 5+yr) as of 2024.",
      "target_schema": "div_05",
      "sql_generated": "SELECT CASE WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, hire_date)) BETWEEN 0 AND 1 THEN '0-1yr' WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, hire_date)) BETWEEN 2 AND 3 THEN '1-3yr' WHEN EXTRACT(YEAR FROM AGE(CURRENT_DATE, hire_date)) BETWEEN 4 AND 5 THEN '3-5yr' ELSE '5+yr' END AS tenure_bucket, COUNT(*) AS employee_count FROM employees WHERE termination_date IS NULL OR termination_date > CURRENT_DATE GROUP BY tenure_bucket LIMIT 1000;",
      "gold_sql": "  SELECT\n    CASE\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2024-12-31', hire_date)) < 1 THEN '0-1 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2024-12-31', hire_date)) < 3 THEN '1-3 yr'\n      WHEN EXTRACT(YEAR FROM AGE(DATE '2024-12-31', hire_date)) < 5 THEN '3-5 yr'\n      ELSE '5+ yr'\n    END AS tenure_bucket,\n    COUNT(*) AS employee_count\n  FROM div_05.employees\n  WHERE hire_date <= DATE '2024-12-31'\n    AND (termination_date IS NULL OR termination_date > DATE '2024-12-31')\n  GROUP BY tenure_bucket\n  ORDER BY tenure_bucket;",
      "success": true,
      "latency_ms": 19824,
      "tags": "hr,temporal"
    },
    {
      "qid": "Q0291",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days between PO order date and goods receipt for each vendor in 2023.",
      "target_schema": "div_20",
      "sql_generated": "SELECT v.vendor_id, v.name AS vendor_name, AVG((gr.receipt_date - po.order_date)) AS avg_days_between_po_and_gr FROM purchase_orders po JOIN goods_receipts gr ON po.po_id = gr.po_id JOIN vendors v ON po.vendor_id = v.vendor_id WHERE EXTRACT(YEAR FROM gr.receipt_date) = 2023 GROUP BY v.vendor_id, v.name LIMIT 1000;",
      "gold_sql": "  SELECT v.name, ROUND(AVG(gr.receipt_date - po.order_date), 2) AS avg_days\n  FROM div_20.purchase_orders po\n  JOIN div_20.goods_receipts gr ON gr.po_id = po.po_id\n  JOIN div_20.vendors v ON v.vendor_id = po.vendor_id\n  WHERE EXTRACT(YEAR FROM po.order_date) = 2023\n  GROUP BY v.name\n  ORDER BY avg_days;",
      "success": true,
      "latency_ms": 12701,
      "tags": "procurement"
    },
    {
      "qid": "Q0292",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Count of statements of work by status for services division div_06.",
      "target_schema": "div_06",
      "sql_generated": "SELECT l.meaning AS status_name, COUNT(s.sow_id) AS count \nFROM svc_statements_of_work s \nJOIN lookup_codes l ON s.status_code = l.code AND l.domain = 'PROJECT_STATUS' \nWHERE s.division = 'div_06' \nGROUP BY l.meaning LIMIT 1000;",
      "gold_sql": "  SELECT lc.meaning AS status, COUNT(*) AS sow_count\n  FROM div_06.svc_statements_of_work sow\n  JOIN div_06.lookup_codes lc ON lc.code = sow.status_code AND lc.domain = 'PROJECT_STATUS'\n  GROUP BY lc.meaning\n  ORDER BY sow_count DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column s.division does not exist",
      "sqlstate": "42703",
      "latency_ms": 13424,
      "tags": "services,lookup"
    },
    {
      "qid": "Q0293",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "QC failure rate for inventory lots in 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT lot_id, COUNT(*) FILTER (WHERE result = 'fail') AS fail_count, COUNT(*) AS total_count, (COUNT(*) FILTER (WHERE result = 'fail') * 100.0 / NULLIF(COUNT(*), 0)) AS failure_rate FROM inventory_qc_inspections WHERE inspection_date BETWEEN '2021-01-01' AND '2021-12-31' GROUP BY lot_id LIMIT 1000;",
      "gold_sql": "  SELECT\n    ROUND(100.0 * SUM(CASE WHEN qi.result = 'fail' THEN 1 ELSE 0 END) / COUNT(*), 2) AS fail_pct\n  FROM div_05.inventory_qc_inspections qi\n  WHERE EXTRACT(YEAR FROM qi.inspection_date) = 2021;",
      "success": true,
      "latency_ms": 14638,
      "tags": "inventory,qc"
    },
    {
      "qid": "Q0294",
      "difficulty": "moderate",
      "template_id": "?",
      "question": "Total POS sales by payment method for retail division div_11.",
      "target_schema": "div_11",
      "sql_generated": "SELECT payment_method_code, SUM(total_amount) AS total_sales FROM rtl_pos_transactions WHERE payment_method_code IN ('CASH', 'CC', 'DC', 'GC', 'MW') GROUP BY payment_method_code LIMIT 1000;",
      "gold_sql": "  SELECT payment_method_code, COUNT(*) AS txn_count,\n         SUM(total_amount) AS total_sales\n  FROM div_11.rtl_pos_transactions\n  GROUP BY payment_method_code\n  ORDER BY total_sales DESC;",
      "success": true,
      "latency_ms": 6926,
      "tags": "retail"
    },
    {
      "qid": "Q0295",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Count inventory adjustments by reason in 2023.",
      "target_schema": "div_03",
      "sql_generated": "SELECT reason, COUNT(*) AS adjustment_count FROM inventory_adjustments WHERE adjustment_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY reason LIMIT 1000;",
      "gold_sql": "  SELECT reason, COUNT(*) AS adjustment_count\n  FROM div_03.inventory_adjustments\n  WHERE EXTRACT(YEAR FROM adjustment_date) = 2023\n  GROUP BY reason;",
      "success": true,
      "latency_ms": 5932,
      "tags": "inventory"
    },
    {
      "qid": "Q0296",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Total employee cost (gross pay) per department for 2022.",
      "target_schema": "div_19",
      "sql_generated": "SELECT d.department_id, d.name AS department_name, SUM(pl.gross_pay) AS total_employee_cost \nFROM payroll_run_line pl \nJOIN employees e ON pl.employee_id = e.employee_id \nJOIN departments d ON e.department_id = d.department_id \nWHERE EXTRACT(YEAR FROM pl.run_date::date) = 2022 \nGROUP BY d.department_id, d.name LIMIT 1000;",
      "gold_sql": "  SELECT d.name,\n         SUM(prl.gross_pay) AS total_cost,\n         COUNT(DISTINCT prl.employee_id) AS employee_count\n  FROM div_19.payroll_run_line prl\n  JOIN div_19.payroll_run_hdr prh ON prh.run_id = prl.run_id\n  JOIN div_19.employees e ON e.employee_id = prl.employee_id\n  JOIN div_19.departments d ON d.department_id = e.department_id\n  WHERE EXTRACT(YEAR FROM prh.pay_period_start) = 2022\n  GROUP BY d.name\n  ORDER BY total_cost DESC;",
      "success": false,
      "error_type": "execution",
      "error_message": "Database error after 3 attempts: column pl.run_date does not exist",
      "sqlstate": "42703",
      "latency_ms": 14432,
      "tags": "hr,finance"
    },
    {
      "qid": "Q0297",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average days from RFQ to vendor response for 2021.",
      "target_schema": "div_05",
      "sql_generated": "SELECT AVG(response_date - rfq_date) AS avg_days_to_response FROM procurement_rfqs rfqs JOIN procurement_rfq_responses responses ON rfqs.rfq_id = responses.rfq_id WHERE EXTRACT(YEAR FROM response_date) = 2021 LIMIT 1000;",
      "gold_sql": "  SELECT ROUND(AVG(r.response_date - q.rfq_date), 2) AS avg_days\n  FROM div_05.procurement_rfqs q\n  JOIN div_05.procurement_rfq_responses r ON r.rfq_id = q.rfq_id\n  WHERE EXTRACT(YEAR FROM q.rfq_date) = 2021;",
      "success": true,
      "latency_ms": 9219,
      "tags": "procurement,time"
    },
    {
      "qid": "Q0298",
      "difficulty": "simple",
      "template_id": "?",
      "question": "Number of comments per support case in 2024.",
      "target_schema": "div_15",
      "sql_generated": "SELECT case_id, COUNT(comment_id) AS comment_count FROM support_ticket_comments WHERE EXTRACT(YEAR FROM comment_ts) = 2024 GROUP BY case_id LIMIT 1000;",
      "gold_sql": "  SELECT case_id, COUNT(*) AS comment_count\n  FROM div_15.support_ticket_comments\n  WHERE EXTRACT(YEAR FROM comment_ts) = 2024\n  GROUP BY case_id;",
      "success": true,
      "latency_ms": 6247,
      "tags": "support"
    },
    {
      "qid": "Q0299",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Average resource allocation percent by role for active SOWs in services division div_10.",
      "target_schema": "div_10",
      "sql_generated": "SELECT r.role_name, AVG(r.allocation_percent) AS avg_allocation\nFROM svc_resource_plan r\nJOIN svc_statements_of_work s ON r.sow_id = s.sow_id\nWHERE s.status_code = 'AC'\nGROUP BY r.role_name LIMIT 1000;",
      "gold_sql": "  SELECT rp.role_name,\n         ROUND(AVG(rp.allocation_percent), 1) AS avg_allocation,\n         COUNT(*) AS assignments\n  FROM div_10.svc_resource_plan rp\n  JOIN div_10.svc_statements_of_work sow ON sow.sow_id = rp.sow_id\n  WHERE sow.status_code = 'AC'\n  GROUP BY rp.role_name\n  ORDER BY avg_allocation DESC;",
      "success": true,
      "latency_ms": 9294,
      "tags": "services,kpi"
    },
    {
      "qid": "Q0300",
      "difficulty": "challenging",
      "template_id": "?",
      "question": "Departments where actual expenses exceed budget in 2021.",
      "target_schema": "div_09",
      "sql_generated": "SELECT \n    b.department_id,\n    d.name AS department_name,\n    SUM(pe.amount) AS actual_expenses,\n    SUM(pb.planned_amount) AS budgeted_amount\nFROM \n    project_budgets pb\nJOIN \n    projects p ON pb.project_id = p.project_id\nJOIN \n    project_expenses pe ON p.project_id = pe.project_id\nJOIN \n    budgets b ON pb.budget_id = b.budget_id\nJOIN \n    departments d ON b.department_id = d.department_id\nWHERE \n    EXTRACT(YEAR FROM pe.expense_date) = 2021\nGROUP BY \n    b.department_id, d.name\nHAVING \n    SUM(pe.amount) > SUM(pb.planned_amount);",
      "gold_sql": "  SELECT d.name, b.total_amount, COALESCE(SUM(pe.amount),0) AS actual_spend\n  FROM div_09.budgets b\n  JOIN div_09.departments d ON d.department_id = b.department_id\n  LEFT JOIN div_09.project_expenses pe ON pe.project_id IS NOT NULL\n  WHERE EXTRACT(YEAR FROM b.created_at) = 2021\n  GROUP BY d.name, b.total_amount\n  HAVING COALESCE(SUM(pe.amount),0) > b.total_amount;",
      "success": false,
      "error_type": "validation",
      "error_message": "Failed to generate valid SQL after 3 attempts",
      "latency_ms": 21659,
      "tags": "finance,projects"
    }
  ]
}